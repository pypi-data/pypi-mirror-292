"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""

import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.message
import typing

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

@typing.final
class AggregateFilterOptions(google.protobuf.message.Message):
    """Options for filtering data during aggregation."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEYS_FIELD_NUMBER: builtins.int
    NAME_FIELD_NUMBER: builtins.int
    MAIN_KEY_FIELD_NUMBER: builtins.int
    SELECTED_OPTIONS_FIELD_NUMBER: builtins.int
    name: builtins.str
    """Name of the filter."""
    main_key: builtins.str
    """Main key used for filtering."""
    @property
    def keys(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """Keys to filter the data by.
        Repeated to allow multiple keys.
        """

    @property
    def selected_options(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """Selected options for the filter.
        Repeated to allow multiple options.
        """

    def __init__(
        self,
        *,
        keys: collections.abc.Iterable[builtins.str] | None = ...,
        name: builtins.str = ...,
        main_key: builtins.str = ...,
        selected_options: collections.abc.Iterable[builtins.str] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["keys", b"keys", "main_key", b"main_key", "name", b"name", "selected_options", b"selected_options"]) -> None: ...

global___AggregateFilterOptions = AggregateFilterOptions

@typing.final
class AggregateStreamRequest(google.protobuf.message.Message):
    """Request message for the AggregateStream RPC method."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PIPELINE_FIELD_NUMBER: builtins.int
    BATCH_SIZE_FIELD_NUMBER: builtins.int
    COLLECTION_FIELD_NUMBER: builtins.int
    QUERY_FIELD_NUMBER: builtins.int
    FILTER_OPTIONS_FIELD_NUMBER: builtins.int
    DEEP_DIVE_FIELD_NUMBER: builtins.int
    OPTIONS_FIELD_NUMBER: builtins.int
    INNER_OPTIONS_FIELD_NUMBER: builtins.int
    pipeline: builtins.bytes
    """Pipeline configuration for the aggregation."""
    batch_size: builtins.int
    """Number of items to include in each batch."""
    collection: builtins.str
    """Name of the collection to aggregate."""
    query: builtins.str
    """Query to apply to the collection."""
    deep_dive: builtins.bytes
    """Additional data for deeper aggregation."""
    options: builtins.bytes
    """Extra options for the aggregation."""
    inner_options: builtins.bytes
    """Inner options for more fine-grained control."""
    @property
    def filter_options(self) -> global___AggregateFilterOptions:
        """Options for filtering data during aggregation."""

    def __init__(
        self,
        *,
        pipeline: builtins.bytes | None = ...,
        batch_size: builtins.int | None = ...,
        collection: builtins.str | None = ...,
        query: builtins.str | None = ...,
        filter_options: global___AggregateFilterOptions | None = ...,
        deep_dive: builtins.bytes | None = ...,
        options: builtins.bytes | None = ...,
        inner_options: builtins.bytes | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["_batch_size", b"_batch_size", "_collection", b"_collection", "_deep_dive", b"_deep_dive", "_filter_options", b"_filter_options", "_inner_options", b"_inner_options", "_options", b"_options", "_pipeline", b"_pipeline", "_query", b"_query", "batch_size", b"batch_size", "collection", b"collection", "deep_dive", b"deep_dive", "filter_options", b"filter_options", "inner_options", b"inner_options", "options", b"options", "pipeline", b"pipeline", "query", b"query"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["_batch_size", b"_batch_size", "_collection", b"_collection", "_deep_dive", b"_deep_dive", "_filter_options", b"_filter_options", "_inner_options", b"_inner_options", "_options", b"_options", "_pipeline", b"_pipeline", "_query", b"_query", "batch_size", b"batch_size", "collection", b"collection", "deep_dive", b"deep_dive", "filter_options", b"filter_options", "inner_options", b"inner_options", "options", b"options", "pipeline", b"pipeline", "query", b"query"]) -> None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_batch_size", b"_batch_size"]) -> typing.Literal["batch_size"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_collection", b"_collection"]) -> typing.Literal["collection"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_deep_dive", b"_deep_dive"]) -> typing.Literal["deep_dive"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_filter_options", b"_filter_options"]) -> typing.Literal["filter_options"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_inner_options", b"_inner_options"]) -> typing.Literal["inner_options"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_options", b"_options"]) -> typing.Literal["options"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_pipeline", b"_pipeline"]) -> typing.Literal["pipeline"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_query", b"_query"]) -> typing.Literal["query"] | None: ...

global___AggregateStreamRequest = AggregateStreamRequest

@typing.final
class AggregateUnaryRequest(google.protobuf.message.Message):
    """Request message for the AggregateUnary RPC method."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PIPELINE_FIELD_NUMBER: builtins.int
    BATCH_SIZE_FIELD_NUMBER: builtins.int
    COLLECTION_FIELD_NUMBER: builtins.int
    QUERY_FIELD_NUMBER: builtins.int
    FILTER_OPTIONS_FIELD_NUMBER: builtins.int
    DEEP_DIVE_FIELD_NUMBER: builtins.int
    OPTIONS_FIELD_NUMBER: builtins.int
    INNER_OPTIONS_FIELD_NUMBER: builtins.int
    NEXT_PAGE_FIELD_NUMBER: builtins.int
    pipeline: builtins.bytes
    """Pipeline configuration for the aggregation."""
    batch_size: builtins.int
    """Number of items to include in each batch."""
    collection: builtins.str
    """Name of the collection to aggregate."""
    query: builtins.str
    """Query to apply to the collection."""
    deep_dive: builtins.bytes
    """Additional data for deeper aggregation."""
    options: builtins.bytes
    """Extra options for the aggregation."""
    inner_options: builtins.bytes
    """Inner options for more fine-grained control."""
    next_page: builtins.int
    """Pagination token for retrieving the next page of results."""
    @property
    def filter_options(self) -> global___AggregateFilterOptions:
        """Options for filtering data during aggregation."""

    def __init__(
        self,
        *,
        pipeline: builtins.bytes | None = ...,
        batch_size: builtins.int | None = ...,
        collection: builtins.str | None = ...,
        query: builtins.str | None = ...,
        filter_options: global___AggregateFilterOptions | None = ...,
        deep_dive: builtins.bytes | None = ...,
        options: builtins.bytes | None = ...,
        inner_options: builtins.bytes | None = ...,
        next_page: builtins.int | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["_batch_size", b"_batch_size", "_collection", b"_collection", "_deep_dive", b"_deep_dive", "_filter_options", b"_filter_options", "_inner_options", b"_inner_options", "_next_page", b"_next_page", "_options", b"_options", "_pipeline", b"_pipeline", "_query", b"_query", "batch_size", b"batch_size", "collection", b"collection", "deep_dive", b"deep_dive", "filter_options", b"filter_options", "inner_options", b"inner_options", "next_page", b"next_page", "options", b"options", "pipeline", b"pipeline", "query", b"query"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["_batch_size", b"_batch_size", "_collection", b"_collection", "_deep_dive", b"_deep_dive", "_filter_options", b"_filter_options", "_inner_options", b"_inner_options", "_next_page", b"_next_page", "_options", b"_options", "_pipeline", b"_pipeline", "_query", b"_query", "batch_size", b"batch_size", "collection", b"collection", "deep_dive", b"deep_dive", "filter_options", b"filter_options", "inner_options", b"inner_options", "next_page", b"next_page", "options", b"options", "pipeline", b"pipeline", "query", b"query"]) -> None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_batch_size", b"_batch_size"]) -> typing.Literal["batch_size"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_collection", b"_collection"]) -> typing.Literal["collection"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_deep_dive", b"_deep_dive"]) -> typing.Literal["deep_dive"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_filter_options", b"_filter_options"]) -> typing.Literal["filter_options"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_inner_options", b"_inner_options"]) -> typing.Literal["inner_options"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_next_page", b"_next_page"]) -> typing.Literal["next_page"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_options", b"_options"]) -> typing.Literal["options"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_pipeline", b"_pipeline"]) -> typing.Literal["pipeline"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_query", b"_query"]) -> typing.Literal["query"] | None: ...

global___AggregateUnaryRequest = AggregateUnaryRequest

@typing.final
class AggregateResponse(google.protobuf.message.Message):
    """Response message for the Aggregate RPC methods."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    DATA_FIELD_NUMBER: builtins.int
    TOTAL_FIELD_NUMBER: builtins.int
    TOTAL_SENT_FIELD_NUMBER: builtins.int
    NEXT_PAGE_FIELD_NUMBER: builtins.int
    PREVIOUS_PAGE_FIELD_NUMBER: builtins.int
    LAST_PAGE_FIELD_NUMBER: builtins.int
    data: builtins.bytes
    """Data returned from the aggregation."""
    total: builtins.int
    """Total number of items that match the query."""
    total_sent: builtins.int
    """Number of items sent in the response."""
    next_page: builtins.int
    """Pagination token for the next page of results."""
    previous_page: builtins.int
    """Pagination token for the previous page of results."""
    last_page: builtins.int
    """Total number of pages available."""
    def __init__(
        self,
        *,
        data: builtins.bytes = ...,
        total: builtins.int = ...,
        total_sent: builtins.int = ...,
        next_page: builtins.int = ...,
        previous_page: builtins.int = ...,
        last_page: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["data", b"data", "last_page", b"last_page", "next_page", b"next_page", "previous_page", b"previous_page", "total", b"total", "total_sent", b"total_sent"]) -> None: ...

global___AggregateResponse = AggregateResponse
