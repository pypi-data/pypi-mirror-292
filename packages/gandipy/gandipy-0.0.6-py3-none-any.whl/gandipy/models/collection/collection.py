# This file was generated by liblab | https://liblab.com/

from typing import List
from ..utils.json_map import JsonMap
from ..base import BaseModel


@JsonMap({})
class ElementTypeParams(BaseModel):
    """Contains additional parameters for a field.

    :param max_length: The maximum length of the string if the data type is VarChar.
    :type max_length: int, optional
    :param dim: The dimension of the field if the data type is Float Vector or Binary Vector.
    :type dim: int, optional
    :param max_capacity: The maximum capacity of the array for the Array data type.
    :type max_capacity: int, optional
    """

    def __init__(
        self, max_length: int = None, dim: int = None, max_capacity: int = None
    ):
        if max_length is not None:
            self.max_length = max_length
        if dim is not None:
            self.dim = dim
        if max_capacity is not None:
            self.max_capacity = max_capacity


@JsonMap(
    {
        "field_name": "fieldName",
        "data_type": "dataType",
        "element_data_type": "elementDataType",
        "is_primary": "isPrimary",
        "is_partition_key": "isPartitionKey",
        "element_type_params": "elementTypeParams",
    }
)
class Field(BaseModel):
    """Represents a field inside a collection.

    :param field_name: The name of the field.
    :type field_name: str, optional
    :param data_type: The data type of the field.
    :type data_type: str, optional
    :param element_data_type: The data type of the elements in the field.
    :type element_data_type: str, optional
    :param is_primary: Specifies whether the field is a primary field.
    :type is_primary: bool, optional
    :param is_partition_key: Specifies whether the field is a partition key.
    :type is_partition_key: bool, optional
    :param element_type_params: An object containing additional parameters for the field.
    :type element_type_params: ElementTypeParams, optional
    """

    def __init__(
        self,
        field_name: str = None,
        data_type: str = None,
        element_data_type: str = None,
        is_primary: bool = None,
        is_partition_key: bool = None,
        element_type_params: ElementTypeParams = None,
    ):
        if field_name is not None:
            self.field_name = field_name
        if data_type is not None:
            self.data_type = data_type
        if element_data_type is not None:
            self.element_data_type = element_data_type
        if is_primary is not None:
            self.is_primary = is_primary
        if is_partition_key is not None:
            self.is_partition_key = is_partition_key
        if element_type_params is not None:
            self.element_type_params = self._define_object(
                element_type_params, ElementTypeParams
            )


@JsonMap({"auto_id": "autoID", "enable_dynamic_field": "enableDynamicField"})
class Schema(BaseModel):
    """Contains configuration for a collection. A valid schema needs to have a primary field and a vector field.

    :param auto_id: Specifies whether the primary field in the schema should be automatically generated.
    :type auto_id: bool, optional
    :param enable_dynamic_field: Specifies whether dynamic fields are enabled in the schema.
    :type enable_dynamic_field: bool, optional
    :param fields: An array of fields representing the fields in the schema.
    :type fields: List[Field], optional
    """

    def __init__(
        self,
        auto_id: bool = None,
        enable_dynamic_field: bool = None,
        fields: List[Field] = None,
    ):
        if auto_id is not None:
            self.auto_id = auto_id
        if enable_dynamic_field is not None:
            self.enable_dynamic_field = enable_dynamic_field
        if fields is not None:
            self.fields = self._define_list(fields, Field)


@JsonMap({"m": "M", "ef_construction": "efConstruction"})
class IndexConfig(BaseModel):
    """Contains additional parameters for an index.

    :param index_type: The type of the index.
    :type index_type: str, optional
    :param m: The maximum degree of the node. Applicable only if index_type is set to HNSW.
    :type m: int, optional
    :param ef_construction: Scope of the search. Applicable only if index_type is set to HNSW.
    :type ef_construction: int, optional
    :param nlist: The value of nlist parameter for the index.
    :type nlist: int, optional
    """

    def __init__(
        self,
        index_type: str = None,
        m: int = None,
        ef_construction: int = None,
        nlist: int = None,
    ):
        if index_type is not None:
            self.index_type = index_type
        if m is not None:
            self.m = m
        if ef_construction is not None:
            self.ef_construction = ef_construction
        if nlist is not None:
            self.nlist = nlist


@JsonMap(
    {"metric_type": "metricType", "field_name": "fieldName", "index_name": "indexName"}
)
class Index(BaseModel):
    """Index

    :param metric_type: The metric type to be used for the index, defaults to "COSINE"
    :type metric_type: str, optional
    :param field_name: The name of the field to be indexed.
    :type field_name: str, optional
    :param index_name: The name of the index.
    :type index_name: str, optional
    :param params: Additional parameters for the index.
    :type params: IndexConfig, optional
    """

    def __init__(
        self,
        metric_type: str = None,
        field_name: str = None,
        index_name: str = None,
        params: IndexConfig = None,
    ):
        if metric_type is not None:
            self.metric_type = metric_type
        if field_name is not None:
            self.field_name = field_name
        if index_name is not None:
            self.index_name = index_name
        if params is not None:
            self.params = self._define_object(params, IndexConfig)


@JsonMap(
    {
        "enable_dynamic_field": "enableDynamicField",
        "shards_num": "shardsNum",
        "partitions_num": "partitionsNum",
        "ttl_seconds": "ttlSeconds",
    }
)
class CollectionParams(BaseModel):
    """Contains additional parameters for a collection.

    :param max_length: The maximum length of the string for a VarChar type field.
    :type max_length: int, optional
    :param enable_dynamic_field: Specifies whether dynamic fields are enabled in the collection.
    :type enable_dynamic_field: bool, optional
    :param shards_num: The number of shards for the collection. Each shard acts as a node that the databes distributes its write operations to.
    :type shards_num: int, optional
    :param partitions_num: The number of partitions for the collection.
    :type partitions_num: int, optional
    :param ttl_seconds: The time-to-live in seconds for the collection. If sent, the collection will be dropped after the given time period.
    :type ttl_seconds: int, optional
    """

    def __init__(
        self,
        max_length: int = None,
        enable_dynamic_field: bool = None,
        shards_num: int = None,
        partitions_num: int = None,
        ttl_seconds: int = None,
    ):
        if max_length is not None:
            self.max_length = max_length
        if enable_dynamic_field is not None:
            self.enable_dynamic_field = enable_dynamic_field
        if shards_num is not None:
            self.shards_num = shards_num
        if partitions_num is not None:
            self.partitions_num = partitions_num
        if ttl_seconds is not None:
            self.ttl_seconds = ttl_seconds


@JsonMap(
    {
        "collection_name": "collectionName",
        "metric_type": "metricType",
        "id_type": "idType",
        "auto_id": "autoID",
        "primary_field_name": "primaryFieldName",
        "vector_field_name": "vectorFieldName",
        "index_params": "indexParams",
    }
)
class Collection(BaseModel):
    """Collection

    :param project_id: ID of the project where the collection will be created.

    :param collection_name: The name of the collection to be created.
    :type collection_name: str
    :param dimension: The dimension of the vectors in the collection.
    :type dimension: int, optional
    :param metric_type: The metric type to be used for the collection, defaults to "COSINE".
    :type metric_type: str, optional
    :param id_type: id_type, The data type of the primary field in the collection.
    :type id_type: str, optional
    :param auto_id: Specifies whether the ID field should be automatically generated.
    :type auto_id: bool, optional
    :param primary_field_name: The name of the primary field in the collection.
    :type primary_field_name: str, optional
    :param vector_field_name: The name of the vector field in the collection.
    :type vector_field_name: str, optional
    :param schema: An object containing the schema configuration for the collection.
    :type schema: Schema, optional
    :param index_params: An array representing the indexes to create in the collection.
    :type index_params: List[Index], optional
    :param params: Additional parameters for the collection.
    :type params: CollectionParams, optional
    """

    def __init__(
        self,
        collection_name: str,
        dimension: int = None,
        metric_type: str = None,
        id_type: str = None,
        auto_id: bool = None,
        primary_field_name: str = None,
        vector_field_name: str = None,
        schema: Schema = None,
        index_params: List[Index] = None,
        params: CollectionParams = None,
    ):
        self.project_id = None
        self.collection_name = collection_name
        if dimension is not None:
            self.dimension = dimension
        if metric_type is not None:
            self.metric_type = metric_type
        if id_type is not None:
            self.id_type = id_type
        if auto_id is not None:
            self.auto_id = auto_id
        if primary_field_name is not None:
            self.primary_field_name = primary_field_name
        if vector_field_name is not None:
            self.vector_field_name = vector_field_name
        if params is not None:
            self.params = self._define_object(params, CollectionParams)
        if schema is not None:
            self.schema = self._define_object(schema, Schema)
        if index_params is not None:
            self.index_params = index_params
