{"version":3,"file":"873.009edd0c74e573f72a34.js?v=009edd0c74e573f72a34","mappings":"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","sources":["webpack://jupyterlab-blockly-extension/./src/icons.ts","webpack://jupyterlab-blockly-extension/./src/index.ts"],"sourcesContent":["import { LabIcon } from '@jupyterlab/ui-components';\n\nimport blockly_logo from '/style/icons/blockly_logo.svg';\n\nexport const blockly_icon = new LabIcon({\n  name: 'blockly:icon/logo',\n  svgstr: blockly_logo\n});\n","import {\n  JupyterFrontEnd,\n  JupyterFrontEndPlugin,\n  ILayoutRestorer\n} from '@jupyterlab/application';\nimport { jsonIcon } from '@jupyterlab/ui-components';\nimport { WidgetTracker, ICommandPalette } from '@jupyterlab/apputils';\nimport { IRenderMimeRegistry } from '@jupyterlab/rendermime';\nimport { IEditorServices } from '@jupyterlab/codeeditor';\nimport { CodeCell } from '@jupyterlab/cells';\nimport { IFileBrowserFactory } from '@jupyterlab/filebrowser';\nimport { ILauncher } from '@jupyterlab/launcher';\nimport { ITranslator } from '@jupyterlab/translation';\nimport { ISettingRegistry } from '@jupyterlab/settingregistry';\nimport { IMainMenu } from '@jupyterlab/mainmenu';\nimport { ReadonlyPartialJSONObject } from '@lumino/coreutils';\n\nimport { IJupyterWidgetRegistry } from '@jupyter-widgets/base';\n\nimport {\n  WidgetRenderer,\n  registerWidgetManager\n} from '@jupyter-widgets/jupyterlab-manager';\n\nimport { BlocklyEditorFactory } from 'jupyterlab-blockly';\nimport { IBlocklyRegistry } from 'jupyterlab-blockly';\nimport { BlocklyEditor } from 'jupyterlab-blockly';\n\nimport { blockly_icon } from './icons';\n\n/**\n * The name of the factory that creates the editor widgets.\n */\nconst FACTORY = 'Blockly editor';\n\nconst PALETTE_CATEGORY = 'Blockly editor';\n\nnamespace CommandIDs {\n  export const createNew = 'blockly:create-new-blockly-file';\n  export const interruptKernel = 'blockly:interrupt-kernel';\n  export const reconnectToKernel = 'blockly:reconnect-to-kernel';\n  export const shutdownKernel = 'blockly:shutdown-kernel';\n  export const restartKernel = 'blockly:restart-kernel';\n}\n\n/**\n * The id of the translation plugin.\n */\nconst PLUGIN_ID = '@jupyterlab/translation-extension:plugin';\n\n/**\n * Initialization data for the jupyterlab-blocky extension.\n */\nconst plugin: JupyterFrontEndPlugin<IBlocklyRegistry> = {\n  id: 'jupyterlab-blocky:plugin',\n  autoStart: true,\n  requires: [\n    ILayoutRestorer,\n    IRenderMimeRegistry,\n    IEditorServices,\n    IFileBrowserFactory,\n    ISettingRegistry,\n    ITranslator\n  ],\n  optional: [ILauncher, ICommandPalette, IMainMenu, IJupyterWidgetRegistry],\n  provides: IBlocklyRegistry,\n  activate: (\n    app: JupyterFrontEnd,\n    restorer: ILayoutRestorer,\n    rendermime: IRenderMimeRegistry,\n    editorServices: IEditorServices,\n    browserFactory: IFileBrowserFactory,\n    settings: ISettingRegistry,\n    translator: ITranslator,\n    launcher: ILauncher | null,\n    palette: ICommandPalette | null,\n    mainMenu: IMainMenu | null,\n    widgetRegistry: IJupyterWidgetRegistry | null\n  ): IBlocklyRegistry => {\n    console.log('JupyterLab extension jupyterlab-blocky is activated!');\n\n    // Namespace for the tracker\n    const namespace = 'jupyterlab-blocky';\n\n    // Creating the tracker for the document\n    const tracker = new WidgetTracker<BlocklyEditor>({ namespace });\n\n    // Handle state restoration.\n    if (restorer) {\n      // When restoring the app, if the document was open, reopen it\n      restorer.restore(tracker, {\n        command: 'docmanager:open',\n        args: widget => ({ path: widget.context.path, factory: FACTORY }),\n        name: widget => widget.context.path\n      });\n    }\n\n    const { commands } = app;\n\n    // Creating the widget factory to register it so the document manager knows about\n    // our new DocumentWidget\n    const widgetFactory = new BlocklyEditorFactory({\n      name: FACTORY,\n      modelName: 'text',\n      fileTypes: ['blockly'],\n      defaultFor: ['blockly'],\n\n      // Kernel options, in this case we need to execute the code generated\n      // in the blockly editor. The best way would be to use kernels, for\n      // that reason, we tell the widget factory to start a kernel session\n      // when opening the editor, and close the session when closing the editor.\n      canStartKernel: true,\n      preferKernel: true,\n      shutdownOnClose: true,\n\n      // The rendermime instance, necessary to render the outputs\n      // after a code execution. And the mimeType service to get the\n      // mimeType from the kernel language, as well as the factory service\n      // for the cell content factory.\n      rendermime: rendermime,\n      mimetypeService: editorServices.mimeTypeService,\n      factoryService: editorServices.factoryService,\n\n      // The translator instance, used for the internalization of the plugin.\n      translator: translator\n    });\n\n    // Add the widget to the tracker when it's created\n    widgetFactory.widgetCreated.connect((sender, widget) => {\n      // Adding the Blockly icon for the widget so it appears next to the file name.\n      widget.title.icon = blockly_icon;\n\n      // Notify the instance tracker if restore data needs to update.\n      widget.context.pathChanged.connect(() => {\n        tracker.save(widget);\n      });\n      tracker.add(widget);\n    });\n    // Registering the file type\n    app.docRegistry.addFileType({\n      name: 'blockly',\n      displayName: 'Blockly',\n      contentType: 'file',\n      fileFormat: 'json',\n      extensions: ['.jpblockly'],\n      mimeTypes: ['application/json'],\n      icon: jsonIcon,\n      iconLabel: 'JupyterLab-Blockly'\n    });\n    // Registering the widget factory\n    app.docRegistry.addWidgetFactory(widgetFactory);\n\n    function getSetting(setting: ISettingRegistry.ISettings): string {\n      // Read the settings and convert to the correct type\n      const currentLocale: string = setting.get('locale').composite as string;\n      return currentLocale;\n    }\n\n    // Wait for the application to be restored and\n    // for the settings for this plugin to be loaded\n    settings.load(PLUGIN_ID).then(setting => {\n      // Read the settings\n      const currentLocale = getSetting(setting);\n\n      // Listen for our plugin setting changes using Signal\n      setting.changed.connect(getSetting);\n\n      // Get new language and call the function that modifies the language name accordingly.\n      // Also, make the transformation to have the name of the language package as in Blockly.\n      const language =\n        currentLocale === 'default'\n          ? 'En'\n          : currentLocale[currentLocale.length - 2].toUpperCase() +\n            currentLocale[currentLocale.length - 1].toLowerCase();\n      console.log(`Current Language : '${language}'`);\n\n      // Transmitting the current language to the manager.\n      widgetFactory.registry.setlanguage(language);\n    });\n\n    commands.addCommand(CommandIDs.createNew, {\n      label: args =>\n        args['isPalette'] ? 'New Blockly Editor' : 'Blockly Editor',\n      caption: 'Create a new Blockly Editor',\n      icon: args => (args['isPalette'] ? null : blockly_icon),\n      execute: async args => {\n        // Get the directory in which the Blockly file must be created;\n        // otherwise take the current filebrowser directory\n        const cwd =\n          args['cwd'] || browserFactory.tracker.currentWidget.model.path;\n\n        // Create a new untitled Blockly file\n        const model = await commands.execute('docmanager:new-untitled', {\n          path: cwd,\n          type: 'file',\n          ext: '.jpblockly'\n        });\n\n        // Open the newly created file with the 'Editor'\n        return commands.execute('docmanager:open', {\n          path: model.path,\n          factory: FACTORY\n        });\n      }\n    });\n\n    // Add the command to the launcher\n    if (launcher) {\n      launcher.add({\n        command: CommandIDs.createNew,\n        category: 'Other',\n        rank: 1\n      });\n    }\n\n    // Add the command to the palette\n    if (palette) {\n      palette.addItem({\n        command: CommandIDs.createNew,\n        args: { isPalette: true },\n        category: PALETTE_CATEGORY\n      });\n    }\n\n    /**\n     * Whether there is an active Blockly Editor.\n     */\n    function isEnabled(): boolean {\n      return (\n        tracker.currentWidget !== null &&\n        tracker.currentWidget === app.shell.currentWidget\n      );\n    }\n\n    // Get the current widget and activate unless the args specify otherwise.\n    function getCurrent(args: ReadonlyPartialJSONObject): BlocklyEditor | null {\n      const widget = tracker.currentWidget;\n      const activate = args['activate'] !== false;\n      if (activate && widget) {\n        app.shell.activateById(widget.id);\n      }\n      return widget ?? null;\n    }\n\n    // Register kernel commands.\n    commands.addCommand(CommandIDs.interruptKernel, {\n      label: 'Interrupt Kernel',\n      execute: args => {\n        const current = getCurrent(args);\n        if (!current) {\n          return;\n        }\n        const kernel = current.context.sessionContext.session?.kernel;\n        if (kernel) {\n          return kernel.interrupt();\n        }\n        return Promise.resolve(void 0);\n      },\n      isEnabled\n    });\n\n    commands.addCommand(CommandIDs.restartKernel, {\n      label: 'Restart Kernel…',\n      execute: args => {\n        const current = getCurrent(args);\n        if (!current) {\n          return;\n        }\n        const kernel = current.context.sessionContext.session?.kernel;\n        if (kernel) {\n          return kernel.restart();\n        }\n        return Promise.resolve(void 0);\n      },\n      isEnabled\n    });\n\n    commands.addCommand(CommandIDs.shutdownKernel, {\n      label: 'Shut Down Kernel',\n      execute: args => {\n        const current = getCurrent(args);\n        if (!current) {\n          return;\n        }\n        return current.context.sessionContext.shutdown();\n      }\n    });\n\n    commands.addCommand(CommandIDs.reconnectToKernel, {\n      label: 'Reconnect to Kernel',\n      execute: args => {\n        const current = getCurrent(args);\n        if (!current) {\n          return;\n        }\n        const kernel = current.context.sessionContext.session?.kernel;\n        if (kernel) {\n          return kernel.reconnect();\n        }\n        return Promise.resolve(void 0);\n      }\n    });\n\n    // Add the command to the main menu\n    if (mainMenu) {\n      mainMenu.kernelMenu.kernelUsers.interruptKernel.add({\n        id: CommandIDs.interruptKernel,\n        isEnabled\n      });\n\n      mainMenu.kernelMenu.kernelUsers.reconnectToKernel.add({\n        id: CommandIDs.reconnectToKernel,\n        isEnabled\n      });\n\n      mainMenu.kernelMenu.kernelUsers.restartKernel.add({\n        id: CommandIDs.restartKernel,\n        isEnabled\n      });\n\n      mainMenu.kernelMenu.kernelUsers.shutdownKernel.add({\n        id: CommandIDs.shutdownKernel,\n        isEnabled\n      });\n    }\n\n    if (widgetRegistry) {\n      tracker.forEach(panel => {\n        registerWidgetManager(\n          panel.context as any,\n          panel.content.rendermime,\n          widgetRenderers([panel.content.cell])\n        );\n      });\n\n      tracker.widgetAdded.connect((sender, panel) => {\n        registerWidgetManager(\n          panel.context as any,\n          panel.content.rendermime,\n          widgetRenderers([panel.content.cell])\n        );\n      });\n    }\n\n    return widgetFactory.registry;\n  }\n};\n\nfunction* widgetRenderers(cells: CodeCell[]): IterableIterator<WidgetRenderer> {\n  for (const w of cells) {\n    if (w instanceof WidgetRenderer) {\n      yield w;\n    }\n  }\n}\n\nexport default plugin;\n"],"names":["blockly_icon","LabIcon","name","svgstr","FACTORY","CommandIDs","widgetRenderers","cells","w","WidgetRenderer","createNew","interruptKernel","reconnectToKernel","shutdownKernel","restartKernel","id","autoStart","requires","ILayoutRestorer","IRenderMimeRegistry","IEditorServices","IFileBrowserFactory","ISettingRegistry","ITranslator","optional","ILauncher","ICommandPalette","IMainMenu","IJupyterWidgetRegistry","provides","IBlocklyRegistry","activate","app","restorer","rendermime","editorServices","browserFactory","settings","translator","launcher","palette","mainMenu","widgetRegistry","console","log","tracker","WidgetTracker","namespace","restore","command","args","widget","path","context","factory","commands","widgetFactory","BlocklyEditorFactory","modelName","fileTypes","defaultFor","canStartKernel","preferKernel","shutdownOnClose","mimetypeService","mimeTypeService","factoryService","getSetting","setting","get","composite","isEnabled","currentWidget","shell","getCurrent","activateById","widgetCreated","connect","sender","title","icon","pathChanged","save","add","docRegistry","addFileType","displayName","contentType","fileFormat","extensions","mimeTypes","jsonIcon","iconLabel","addWidgetFactory","load","then","currentLocale","changed","language","length","toUpperCase","toLowerCase","registry","setlanguage","addCommand","label","caption","execute","async","cwd","model","type","ext","category","rank","addItem","isPalette","current","kernel","sessionContext","session","interrupt","Promise","resolve","restart","shutdown","reconnect","kernelMenu","kernelUsers","forEach","panel","registerWidgetManager","content","cell","widgetAdded"],"sourceRoot":""}