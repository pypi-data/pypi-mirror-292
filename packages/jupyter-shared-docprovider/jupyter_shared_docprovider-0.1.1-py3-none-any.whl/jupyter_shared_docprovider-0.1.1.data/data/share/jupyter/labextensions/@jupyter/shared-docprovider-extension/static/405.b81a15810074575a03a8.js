"use strict";(self.webpackChunk_jupyter_shared_docprovider_extension=self.webpackChunk_jupyter_shared_docprovider_extension||[]).push([[405],{405:(e,t,s)=>{s.r(t),s.d(t,{ISharedDrive:()=>y,SharedDrive:()=>_,WebrtcProvider:()=>l});var i=s(262),r=s(482),n=s(206),o=s(602),a=s(74),h=s(465);class l{constructor(e){this._onSync=e=>{e.synced&&this._ready.resolve()},this._ready=new i.PromiseDelegate,this._isDisposed=!1,this._path=e.path,this._contentType=e.contentType,this._format=e.format,this._sharedModel=e.model,this._awareness=e.model.awareness,this._yWebrtcProvider=null,this._signalingServers=e.signalingServers;const t=e.user;t.ready.then((()=>{this._onUserChanged(t)})).catch((e=>console.error(e))),t.userChanged.connect(this._onUserChanged,this),this._connect().catch((e=>console.warn(e)))}get isDisposed(){return this._isDisposed}get ready(){return this._ready.promise}dispose(){var e;this.isDisposed||(this._isDisposed=!0,null===(e=this._yWebrtcProvider)||void 0===e||e.destroy(),o.Signal.clearData(this))}async _connect(){this._yWebrtcProvider=new r.WebrtcProvider(`${this._format}:${this._contentType}:${this._path}}`,this._sharedModel.ydoc,{signaling:this._signalingServers,awareness:this._awareness}),this._yWebrtcProvider.on("synced",this._onSync)}_onUserChanged(e){this._awareness.setLocalStateField("user",e.identity)}}const d=JSON.parse(a.PageConfig.getOption("signalingServers")),c={name:"",path:"",type:"",writable:!0,created:"",last_modified:"",mimetype:"",content:"",format:null};class _{constructor(e,t,s,c,_){this._onSync=e=>{var t;e.synced&&(this._ready.resolve(),null===(t=this._fileSystemProvider)||void 0===t||t.off("synced",this._onSync))},this._onCreate=(e,t)=>{if("string"!=typeof e.format)return;if(void 0===this._fileSystemContent.get(e.path))return;const s=`${e.format}:${e.contentType}:${e.path}`,i=new l({url:"",path:e.path,format:e.format,contentType:e.contentType,model:t,user:this._user,translator:this._trans,signalingServers:this._signalingServers});this._fileProviders.set(s,i),t.disposed.connect((()=>{const e=this._fileProviders.get(s);e&&(e.dispose(),this._fileProviders.delete(s))}))},this._fileChanged=new o.Signal(this),this._isDisposed=!1,this._ready=new i.PromiseDelegate,this._signalingServers=[],this._user=e,this._trans=s,this._globalAwareness=c,this._fileProviders=new Map,this.sharedModelFactory=new m(this._onCreate),this.serverSettings=h.ServerConnection.makeSettings(),d.forEach((e=>{e.startsWith("ws://")||e.startsWith("wss://")?this._signalingServers.push(e):this._signalingServers.push(a.URLExt.join(this.serverSettings.wsUrl,e))})),this.name=_,this._fileSystemYdoc=new n.Doc,this._fileSystemContent=this._fileSystemYdoc.getMap("content"),this._fileSystemProvider=new r.WebrtcProvider("fileSystem",this._fileSystemYdoc,{signaling:this._signalingServers,awareness:this._globalAwareness||void 0}),this._fileSystemProvider.on("synced",this._onSync)}getDownloadUrl(e){return new Promise((e=>{e("")}))}delete(e){return new Promise((e=>{e()}))}restoreCheckpoint(e,t){return new Promise((e=>{e()}))}deleteCheckpoint(e,t){return new Promise((e=>{e()}))}async newUntitled(e={}){if("directory"===e.type)throw new Error("Cannot create directory");let t;t="notebook"===e.type?"ipynb":"txt";let s=0,i="";const r=this._fileSystemContent.toJSON();for(;""===i;){const e=`untitled${s}.${t}`;e in r?s+=1:i=e}const o={name:i,path:i,type:"file",writable:!0,created:"",last_modified:"",mimetype:"",content:null,format:null},a=new n.Map;return this._fileSystemContent.set(i,a),this._fileChanged.emit({type:"new",oldValue:null,newValue:o}),o}async rename(e,t){const s=this._fileSystemContent.toJSON();if(e in s&&this._fileSystemContent.delete(e),!(t in s)){const e=new n.Map;this._fileSystemContent.set(t,e)}return{name:t,path:t,type:"file",writable:!0,created:"",last_modified:"",mimetype:"",content:null,format:null}}copy(e,t){return new Promise((e=>{e(c)}))}createCheckpoint(e){const t={id:"",last_modified:""};return new Promise((e=>{e(t)}))}listCheckpoints(e){return new Promise((e=>{e([])}))}get fileChanged(){return this._fileChanged}get isDisposed(){return this._isDisposed}dispose(){this.isDisposed||(this._fileProviders.forEach((e=>e.dispose())),this._fileProviders.clear(),this._isDisposed=!0,o.Signal.clearData(this))}async get(e,t){let s;if(await this._ready,t&&t.format&&t.type){const i=`${t.format}:${t.type}:${e}`;if(this._fileProviders.get(i))return s={name:e,path:e,type:"file",writable:!0,created:"",last_modified:"",mimetype:"",content:null,format:null},new Promise((e=>{e(s)}))}const i=[];return""===e?(this._fileSystemContent.forEach(((e,t)=>{i.push({name:t,path:t,type:"file",writable:!0,created:"",last_modified:"",mimetype:"",content:null,format:null})})),s={name:"",path:"",type:"directory",writable:!1,created:"",last_modified:"",mimetype:"",content:i,format:null}):s={name:e,path:e,type:"file",writable:!0,created:"",last_modified:"",mimetype:"",content:null,format:null},new Promise((e=>{e(s)}))}async save(e,t={}){if(t.format&&t.type){const s=`${t.format}:${t.type}:${e}`;if(this._fileProviders.get(s)){const s={type:t.type,format:t.format,content:!1};return this.get(e,s)}}return new Promise((e=>{e(c)}))}}class m{constructor(e){this._onCreate=e,this._documentFactories=new Map}registerDocumentFactory(e,t){if(this._documentFactories.has(e))throw new Error(`The content type ${e} already exists`);this._documentFactories.set(e,t)}createNew(e){if("string"==typeof e.format){if(this._documentFactories.has(e.contentType)){const t=this._documentFactories.get(e.contentType)(e);return this._onCreate(e,t),t}}else console.warn(`Only defined format are supported; got ${e.format}.`)}}const y=new i.Token("@jupyter/shared-drive-extension:ISharedDrive")}}]);