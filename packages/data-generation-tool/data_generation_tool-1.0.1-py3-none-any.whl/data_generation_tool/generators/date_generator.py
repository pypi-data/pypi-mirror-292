from datetime import datetime, timedelta

from data_generation_tool.constraints.column_constraints import Future, Past, After, Before, Period, Mode, DateFormat, \
    IncrementStep, IncrementUnit
from data_generation_tool.errors import UnsatisfiableConstraints
from data_generation_tool.generators import ColumnGenerator
from data_generation_tool.requests import ColumnGenerationRequest


class DateGenerator(ColumnGenerator):
    """
    Generator for date columns.
    """

    def generate(self, column: ColumnGenerationRequest, count: int) -> list:
        """
        Generates a list of dates based on the constraints provided in the column request.

        Parameters
        ----------
        column : ColumnGenerationRequest
            The request for generating the given column : contains the constraints
        count : int
            The number of values to return

        Returns
        -------
        list
            The data generated

        Raises
        -------
        ValueError
            If the expected type in the column does not match the type of values generated by the generator.

        UnsatisfiableConstraints
            If the given set of constraints are not satisfiable.
        """
        now = datetime.now()
        start_date = datetime.strptime('1970-01-01', '%Y-%m-%d')
        end_date = datetime.strptime('2200-12-31', '%Y-%m-%d')
        date_format = _date_formats["full_with_sec"]
        mode = "random"
        increment_step = 1
        increment_unit = "day"

        for constraint in column.constraints:
            if isinstance(constraint, Future):
                start_date = max(start_date, now)
            elif isinstance(constraint, Past):
                end_date = min(end_date, now)
            elif isinstance(constraint, After):
                start_date = max(start_date, constraint.value)
            elif isinstance(constraint, Before):
                end_date = min(end_date, constraint.value)
            elif isinstance(constraint, Period):
                start_date = max(start_date, constraint.lower_bound)
                end_date = min(end_date, constraint.upper_bound)
            elif isinstance(constraint, Mode):
                mode = constraint.value
            elif isinstance(constraint, DateFormat):
                date_format = constraint.value
            elif isinstance(constraint, IncrementStep):
                increment_step = constraint.value
            elif isinstance(constraint, IncrementUnit):
                increment_unit = constraint.value

        if start_date > end_date:
            raise UnsatisfiableConstraints("The constraints are unsatisfiable.")

        date_list = []
        if mode == "random":
            for _ in range(count):
                random_date = start_date + timedelta(
                    days=self.rng.integers(0, (end_date - start_date).days, endpoint=True))
                date_list.append(random_date.strftime(date_format))
        elif mode == "incremental":
            if increment_unit == "second":
                delta = increment_step * timedelta(seconds=1)
            elif increment_unit == "minute":
                delta = increment_step * timedelta(minutes=1)
            elif increment_unit == "hour":
                delta = increment_step * timedelta(hours=1)
            elif increment_unit == "day":
                delta = increment_step * timedelta(days=1)
            else:
                raise UnsatisfiableConstraints("Unsupported increment_unit. Use 'second', 'minute', 'hour', or 'day'.")

            for i in range(count):
                incremental_date = start_date + i * delta
                date_list.append(incremental_date.strftime(date_format))
        else:
            raise UnsatisfiableConstraints("Unsupported mode. Use 'random' or 'incremental'.")

        return self.post_processing(date_list, column.constraints)


_date_formats = {
    "iso_with_sec": "%Y-%m-%d %H:%M:%S",
    "iso_with_min": "%Y-%m-%d %H:%M",
    "iso": "%Y-%m-%d",
    "us_with_sec_p": "%m-%d-%Y %I:%M:%S %p",
    "us_with_sec": "%m-%d-%Y %H:%M:%S",
    "us_with_min": "%m-%d-%Y %H:%M",
    "us": "%m-%d-%Y",
    "eu_with_sec": "%d/%m/%Y %H:%M:%S",
    "eu_with_min": "%d/%m/%Y %H:%M",
    "eu": "%d/%m/%Y",
    "long_with_sec": "%B %d, %Y %H:%M:%S",
    "long_with_sec_b": "%H:%M:%S %B %d, %Y",
    "long_with_min": "%B %d, %Y %H:%M",
    "long_with_min_b": "%H:%M %B %d, %Y",
    "long": "%B %d, %Y",
    "full_with_sec": "%A, %d %B %Y %H:%M:%S",
    "full_with_min": "%A, %d %B %Y %H:%M",
    "full": "%A, %d %B %Y",
    "short_year_with_sec": "%y-%m-%d %Y %H:%M:%S",
    "short_year": "%y-%m-%d",
    "compact_with_sec": "%Y%m%d%H%M%S",
    "compact": "%Y%m%d",
    "with_seconds": "%Y-%m-%d %H:%M:%S",
    "with_minutes": "%Y-%m-%d %H:%M",
    "with_hours": "%Y-%m-%d %H"
}

_modes = {
    "Random": "random",
    "Incr√©mental": "incremental"
}

_incremental_units = {
    "Seconde": "second",
    "Minute": "minute",
    "Heure": "hour",
    "Jour": "day"
}
