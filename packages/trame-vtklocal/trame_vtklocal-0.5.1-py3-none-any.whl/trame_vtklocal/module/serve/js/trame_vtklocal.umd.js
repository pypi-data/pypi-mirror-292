(function(d,a){typeof exports=="object"&&typeof module<"u"?a(exports,require("vue")):typeof define=="function"&&define.amd?define(["exports","vue"],a):(d=typeof globalThis<"u"?globalThis:d||self,a(d.trame_vtklocal={},d.Vue))})(this,function(d,a){"use strict";async function U(r,c){const l={canvas:r,locateFile(){return c},print(){console.info(Array.prototype.slice.call(arguments).join(" "))},printErr(){console.error(Array.prototype.slice.call(arguments).join(" "))}},w=await window.createVTKWasmSceneManager(l);return w.initialize(),w}function W(r,c){const l=Number(c);return r.updateStateFromObject(l),r.getState(l)}function C(r,c,l){return function(){for(const[w,v]of Object.entries(l)){const g={};for(const[m,b]of Object.entries(v)){const h=W(c,m);if(typeof b=="string")g[b]=h;else for(const[y,p]of Object.entries(b))g[p]=h[y]}r.state.set(w,g)}}}const R={VtkLocal:{emits:["updated","memory-vtk","memory-arrays","camera"],props:{renderWindow:{type:Number},eagerSync:{type:Boolean,default:!1},cacheSize:{type:Number,default:1e8},wsClient:{type:Object},listeners:{type:Object}},setup(r,{emit:c}){const l=a.inject("trame"),w=l.state.get("__trame_vtklocal_wasm_url"),v=[],g=[],m=[],b=a.ref(null),h=a.ref(null),y=r.wsClient||(l==null?void 0:l.client),p={},S={},B={},M=a.ref(1),z=a.toRef(r,"listeners");let t=null,O=0,j=null;function A([e]){if(e.type==="state"){const{mtime:o,content:s,id:n}=e;t.unRegisterState(n),t.registerState(s),p[n]=o}if(e.type==="blob"){const{hash:o,content:s}=e;B[o]=new Promise(n=>{s.arrayBuffer?s.arrayBuffer().then(i=>{t.registerBlob(o,new Uint8Array(i)),n()}):(t.registerBlob(o,s),n())})}}async function V(){const e=y.getConnection().getSession();j=e.subscribe("vtklocal.subscriptions",A),await e.call("vtklocal.subscribe.update",[r.renderWindow,1])}async function _(){const e=y.getConnection().getSession();j&&(e.unsubscribe(j),j=null),await e.call("vtklocal.subscribe.update",[r.renderWindow,-1])}function x(){const{width:e,height:o}=b.value.getBoundingClientRect(),s=Math.floor(e*window.devicePixelRatio+.5),n=Math.floor(o*window.devicePixelRatio+.5),i=a.unref(h);i&&t&&r.renderWindow&&(i.width=s,i.height=n,t.setSize(r.renderWindow,s,n),t.render(r.renderWindow))}let T=new ResizeObserver(x);async function P(e){const s=await y.getConnection().getSession().call("vtklocal.get.state",[e]);return s.length>0?(p[e]=JSON.parse(s).MTime,t.unRegisterState(e),t.registerState(s)):console.log(`Server returned empty state for ${e}`),s}async function L(e){if(B[e]){await B[e],S[e]=a.unref(M),delete B[e];return}const s=await y.getConnection().getSession().call("vtklocal.get.hash",[e]),n=s.arrayBuffer?new Uint8Array(await s.arrayBuffer()):s;return t.registerBlob(e,n),S[e]=a.unref(M),n}function D(){const e=t.getTotalVTKDataObjectMemoryUsage(),o=t.getTotalBlobMemoryUsage(),s=Number(r.cacheSize)+e;if(o>s){const n={};let i=a.unref(M);for(Object.entries(S).forEach(([f,u])=>{u<i&&(i=u);const E=u.toString();n[E]?n[E].push(f):n[E]=[f]});t.getTotalBlobMemoryUsage()>s;){const f=n[i];if(f)for(let u=0;u<f.length;u++)t.unRegisterBlob(f[u]),delete S[f[u]];i++}}c("memory-vtk",t.getTotalVTKDataObjectMemoryUsage()),c("memory-arrays",t.getTotalBlobMemoryUsage())}async function k(){if(O++,O===1)try{const o=await y.getConnection().getSession().call("vtklocal.get.status",[r.renderWindow]),s=[];o.ids.forEach(([n,i])=>{(!p[n]||p[n]<i)&&s.push(P(n))}),v.push(...o.cameras),o.ignore_ids.forEach(n=>{t.unRegisterState(n)}),o.hashes.forEach(n=>{S[n]||s.push(L(n)),S[n]=a.unref(M)}),await Promise.all(s),M.value++;try{t.updateObjectsFromStates(),t.render(r.renderWindow),x()}catch(n){console.error("WASM update failed"),console.log(n)}c("updated"),D()}catch(e){console.error("Error in update",e)}finally{O--,O&&(O=0,await k())}}function F(e){t.resetCamera(e),t.render(r.renderWindow)}a.onMounted(async()=>{t=await U(a.unref(h),w),r.eagerSync&&V(),await k();for(let e=0;e<v.length;e++){const o=Number(v[e]);g.push([o,t.addObserver(o,"ModifiedEvent",()=>{c("camera",W(t,o))})])}t.startEventLoop(r.renderWindow),T&&T.observe(a.unref(b))}),a.onBeforeUnmount(()=>{for(j&&_();g.length;){const[e,o]=g.pop();t.removeObserver(e,o)}for(;m.length;){const[e,o]=m.pop();t.removeObserver(e,o)}t.stopEventLoop(r.renderWindow),T&&(T.disconnect(),T=null)}),a.watchEffect(()=>{for(;m.length;){const[e,o]=m.pop();t.removeObserver(e,o)}for(const[e,o]of Object.entries(z.value||{})){const s=Number(e);for(const[n,i]of Object.entries(o||{})){const f=C(l,t,i);m.push([s,t.addObserver(s,n,f)]),f()}}});function K(e){console.log("definition",e),C(l,t,e)()}return{container:b,canvas:h,update:k,resetCamera:F,evalStateExtract:K}},template:`
        <div ref="container" style="position: relative; width: 100%; height: 100%;">
          <canvas 
            id="canvas"
            ref="canvas" 
            style="position: absolute; left: 0; top: 0; width: 100%; height: 100%;" 
            tabindex="0"
            
            @contextmenu.prevent
            @click="canvas.focus()"
            @mouseenter="canvas.focus()"
          />
        </div>`}};function N(r){Object.keys(R).forEach(c=>{r.component(c,R[c])})}d.install=N,Object.defineProperty(d,Symbol.toStringTag,{value:"Module"})});
