"""Message types for agent-LLM communication in the FlexAI framework."""

from __future__ import annotations
from dataclasses import dataclass
from typing import Any
import json


@dataclass(frozen=True, kw_only=True)
class Message:
    """Base class for all message types in the conversation flow."""

    # The role of the message (user, system, AI, tool).
    role: str

    # The content of the message.
    content: str


@dataclass(frozen=True, kw_only=True)
class SystemMessage(Message):
    """A system message."""

    role: str = "system"


@dataclass(frozen=True, kw_only=True)
class UserMessage(Message):
    """A message sent by a user."""

    role: str = "user"


@dataclass(frozen=True, kw_only=True)
class AIMessage(Message):
    """A message generated by the AI."""

    role: str = "assistant"

    # Token usage for the input that generated this output
    input_tokens: int = 0

    # Token usage to generate this output
    output_tokens: int = 0


@dataclass(frozen=True, kw_only=True)
class ToolUseMessage(AIMessage):
    """A message to use a tool."""

    # Identifier for the tool use.
    id: str

    # Name of the tool being invoked.
    tool_name: str

    # Input arguments for the tool.
    input: Any


@dataclass(frozen=True, kw_only=True)
class ToolResultMessage(UserMessage):
    """A message containing the result of a tool use."""

    # Associated tool use ID.
    tool_use_id: str

    # Time taken to execute the tool.
    execution_time: float

    # Whether an error occurred during tool execution.
    is_error: bool

    @classmethod
    def from_result(
        cls, tool_use_id: str, result: Any, execution_time: float
    ) -> ToolResultMessage:
        """Create a tool result message from a tool result.

        Args:
            tool_use_id: The ID of the tool use.
            result: The result of the tool (or an exception).

        Returns:
            A tool result message.
        """
        # The base message data.
        data = {
            "type": "tool_result",
            "content": result,
        }
        is_error = False

        # Check for an exception.
        if isinstance(result, Exception):
            data.update(
                {
                    "content": str(result),
                }
            )
            is_error = True

        # Return the message.
        return cls(
            tool_use_id=tool_use_id,
            is_error=is_error,
            execution_time=execution_time,
            content=json.dumps([data]),
        )
