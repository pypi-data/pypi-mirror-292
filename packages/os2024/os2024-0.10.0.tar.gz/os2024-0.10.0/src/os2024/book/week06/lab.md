# Lab: 주소 변환 시뮬레이션

이 프로그램은 베이스(base)와 바운드(bound) 레지스터를 사용하는 시스템에서 주소 변환 과정을 시뮬레이션할 수 있게 해줍니다. 이 프로그램을 통해 베이스와 바운드의 기본 개념을 이해하고 실습해볼 수 있습니다.

실습은 두 단계로 진행됩니다.

1. 먼저 `-c` 플래그 없이 프로그램을 실행하여 주소 변환을 직접 시도해봅니다.
2. 그 다음 `-c` 플래그와 함께 실행하여 정답을 확인합니다.

## 주요 개념 설명

- 베이스 레지스터(base register): 프로세스의 주소 공간이 시작되는 물리 메모리 주소를 저장하는 레지스터입니다.
- 바운드 레지스터(bound register): 프로세스의 주소 공간 크기를 저장하는 레지스터입니다. 이를 통해 프로세스가 허용된 메모리 영역 내에서만 접근하도록 제한합니다.
- 주소 변환(address translation): 가상 주소를 물리 주소로 매핑하는 과정입니다. 베이스와 바운드 레지스터를 사용하여 변환을 수행합니다.
- 세그멘테이션 위반(segmentation violation): 프로세스가 허용된 메모리 영역 밖에 접근하려고 할 때 발생하는 예외입니다.

## 메모리 레이아웃 가정

이 실습에서는 일반적인 메모리 레이아웃과는 다른 구조를 가정합니다.

- 코드(code) 섹션이 주소 공간의 시작 부분에 위치
- 고정 크기의 작은 스택(stack)이 코드 섹션 바로 뒤에 위치
- 힙(heap)이 스택 뒤에 위치하며, 아래쪽(높은 주소)으로 성장

```
-------------- 0KB
|    Code    |
-------------- 2KB
|   Stack    |
-------------- 4KB
|    Heap    |
|     |     |
|     v     |
-------------- 7KB
|   (free)   |
|    ...     |
```

위 그림에서 바운드 레지스터는 주소 공간의 끝을 나타내는 7KB로 설정됩니다.

- 0 ~ 7KB 범위 내의 주소 참조는 유효한 것으로 간주
- 7KB를 초과하는 주소 참조는 범위를 벗어난 것으로 간주되어 하드웨어 예외 발생

## 프로그램 실행 예시

### 기본 실행

커맨드 라인에서 `relocation.py`를 입력하여 기본 플래그로 실행할 수 있습니다.

```
prompt> ./relocation.py
...
Base-and-Bounds register information:
  Base   : 0x00003082 (decimal 12418)
  Limit  : 472

Virtual Address Trace
  VA  0: 0x01ae (decimal:430) --> PA or segmentation violation?
  VA  1: 0x0109 (decimal:265) --> PA or segmentation violation?
  VA  2: 0x020b (decimal:523) --> PA or segmentation violation?
  VA  3: 0x019e (decimal:414) --> PA or segmentation violation?
  VA  4: 0x0322 (decimal:802) --> PA or segmentation violation?
```

위와 같이 무작위로 생성된 가상 주소(VA)에 대해, 각각 물리 주소(PA)로 변환될 수 있는지 혹은 세그멘테이션 위반이 발생하는지 직접 판단해봅니다.

### 정답 확인

`-c` 플래그를 사용하여 정답을 확인할 수 있습니다.

```
prompt> ./relocation.py -c
...
Virtual Address Trace
  VA  0: 0x01ae (decimal:430) --> VALID: 0x00003230 (decimal:12848)
  VA  1: 0x0109 (decimal:265) --> VALID: 0x0000318b (decimal:12683)
  VA  2: 0x020b (decimal:523) --> SEGMENTATION VIOLATION
  VA  3: 0x019e (decimal:414) --> VALID: 0x00003220 (decimal:12832)
  VA  4: 0x0322 (decimal:802) --> SEGMENTATION VIOLATION
```

베이스 값이 12418(0x3082)이고 바운드가 472일 때,

- 430(0x01ae)은 베이스에 더했을 때 12848로, 바운드 내에 있으므로 유효한 주소
- 523(0x020b), 802(0x0322)는 바운드인 472를 초과하므로 세그멘테이션 위반

## 추가 플래그

다음과 같은 플래그를 사용하여 프로그램을 더 세밀하게 제어할 수 있습니다:

```
prompt> ./relocation.py -h
Usage: relocation.py [options]

Options:
  -h, --help            show this help message and exit
  -s SEED, --seed=SEED  the random seed
  -a ASIZE, --asize=ASIZE address space size (e.g., 16, 64k, 32m)
  -p PSIZE, --physmem=PSIZE physical memory size (e.g., 16, 64k)
  -n NUM, --addresses=NUM   number of virtual addresses to generate
  -b BASE, --b=BASE     value of base register
  -l LIMIT, --l=LIMIT   value of limit register
  -c, --compute         compute answers for me
```

- `-a`: 가상 주소 공간의 크기 설정
- `-p`: 물리 메모리의 크기 설정
- `-n`: 생성할 가상 주소의 개수 설정
- `-b`: 프로세스의 베이스 레지스터 값 설정
- `-l`: 프로세스의 바운드 레지스터 값 설정

이 플래그들을 사용하여 다양한 조건에서 주소 변환을 실습해볼 수 있습니다.

## 실습 과제

이 코드를 활용하여 메모리 메커니즘을 이해하기 위한 유용한 실험을 수행해보세요.

1. 다양한 주소 공간 크기와 물리 메모리 크기 조합 실험

   - 주소 공간 크기를 물리 메모리 크기보다 작게 설정 (예: -a 16k -p 32k)
   - 주소 공간 크기를 물리 메모리 크기보다 크게 설정 (예: -a 32k -p 16k)
   - 주소 공간 크기와 물리 메모리 크기를 동일하게 설정 (예: -a 16k -p 16k)

   이를 통해 주소 공간과 물리 메모리 크기의 관계가 주소 변환에 어떤 영향을 미치는지 관찰할 수 있습니다.

2. 베이스 레지스터 값의 변화에 따른 영향 관찰

   - 베이스 레지스터 값을 0으로 설정 (예: -b 0)
   - 베이스 레지스터 값을 물리 메모리 크기와 같게 설정 (예: -b 16384 -p 16k)
   - 베이스 레지스터 값을 물리 메모리 크기보다 크게 설정 (예: -b 32768 -p 16k)

   베이스 레지스터 값의 변화가 주소 변환 결과와 세그멘테이션 위반 발생에 어떤 영향을 주는지 확인할 수 있습니다.

3. 바운드 레지스터 값의 변화에 따른 영향 관찰

   - 바운드 레지스터 값을 주소 공간 크기보다 작게 설정 (예: -l 1024 -a 16k)
   - 바운드 레지스터 값을 주소 공간 크기와 같게 설정 (예: -l 16384 -a 16k)
   - 바운드 레지스터 값을 주소 공간 크기보다 크게 설정 (예: -l 32768 -a 16k)

   바운드 레지스터 값의 변화가 유효한 주소 범위와 세그멘테이션 위반 발생에 어떤 영향을 주는지 관찰할 수 있습니다.

4. 대량의 가상 주소 생성 및 변환 실험

   - 가상 주소 생성 개수를 크게 설정 (예: -n 1000)
   - 다양한 주소 공간 크기, 물리 메모리 크기, 베이스 및 바운드 값 조합과 함께 실험

   대량의 가상 주소를 생성하고 변환하는 과정에서 메모리 메커니즘의 성능과 한계를 확인할 수 있습니다.

5. 극단적인 조건에서의 메모리 메커니즘 동작 확인

   - 주소 공간 크기를 1바이트로 설정 (예: -a 1)
   - 물리 메모리 크기를 1바이트로 설정 (예: -p 1)
   - 베이스 레지스터 값을 음수로 설정 (예: -b -1024)
   - 바운드 레지스터 값을 0으로 설정 (예: -l 0)

   이러한 극단적인 조건에서 메모리 메커니즘이 어떻게 동작하는지, 어떤 에러 메시지가 출력되는지 관찰할 수 있습니다.

6. 베이스 레지스터 값을 고정하고 바운드 레지스터 값 변화 관찰

   - 베이스 레지스터 값을 0으로 고정 (예: -b 0)
   - 바운드 레지스터 값을 점진적으로 증가 (예: -l 1024, -l 2048, -l 4096, ...)

   베이스 레지스터 값이 고정된 상태에서 바운드 레지스터 값의 변화가 유효한 주소 범위에 어떤 영향을 주는지 관찰할 수 있습니다.

7. 바운드 레지스터 값을 고정하고 베이스 레지스터 값 변화 관찰

   - 바운드 레지스터 값을 주소 공간 크기의 절반으로 고정 (예: -l 8192 -a 16k)
   - 베이스 레지스터 값을 점진적으로 증가 (예: -b 0, -b 4096, -b 8192, ...)

   바운드 레지스터 값이 고정된 상태에서 베이스 레지스터 값의 변화가 유효한 주소 범위와 물리 메모리 매핑에 어떤 영향을 주는지 확인할 수 있습니다.

8. 주소 공간 크기를 변화시키며 세그멘테이션 위반 발생 패턴 관찰

   - 물리 메모리 크기와 바운드 레지스터 값을 고정 (예: -p 16k -l 8192)
   - 주소 공간 크기를 점진적으로 증가 (예: -a 4k, -a 8k, -a 16k, -a 32k, ...)

   주소 공간 크기의 변화에 따라 세그멘테이션 위반이 발생하는 패턴과 비율이 어떻게 달라지는지 관찰할 수 있습니다.

9. 물리 메모리 크기를 변화시키며 주소 변환 패턴 관찰

   - 주소 공간 크기와 바운드 레지스터 값을 고정 (예: -a 16k -l 8192)
   - 물리 메모리 크기를 점진적으로 증가 (예: -p 16k, -p 32k, -p 64k, ...)

   물리 메모리 크기의 변화가 주소 변환 결과와 세그멘테이션 위반 발생에 어떤 영향을 주는지 확인할 수 있습니다.

10. 랜덤 시드 값을 변경하며 주소 변환 결과 비교

    - 동일한 조건(주소 공간 크기, 물리 메모리 크기, 베이스/바운드 값)에서 랜덤 시드 값만 변경 (예: -s 1, -s 2, -s 3, ...)

    랜덤 시드 값을 변경하며 생성되는 가상 주소 시퀀스와 주소 변환 결과를 비교함으로써, 랜덤성이 메모리 메커니즘에 미치는 영향을 이해할 수 있습니다.

이러한 실험들을 통해 메모리 메커니즘의 동작을 보다 세부적으로 분석하고, 다양한 조건에서의 주소 변환 패턴과 세그멘테이션 위반 발생 경향을 파악할 수 있습니다. 이는 운영체제 개발자와 시스템 프로그래머가 메모리 관리 기법을 최적화하고 안정성을 향상시키는 데 도움이 될 것입니다.
