# Week 3 Homework

## 1. SJF와 FIFO 스케줄러의 응답 시간 및 반환 시간 (작업 길이 200, 3개 작업)

| 작업   | SJF | FIFO |
| ------ | --- | ---- |
| 1      | 0   | 0    |
| 2      | 200 | 200  |
| 3      | 400 | 600  |
| **총** | 600 | 800  |

**분석**

- SJF는 짧은 작업부터 순서대로 처리하기 때문에 FIFO보다 평균 응답 시간과 반환 시간이 짧습니다.
- 이는 SJF가 시스템 전체의 대기 시간을 줄이는 데 효과적임을 보여줍니다.

## 2. 작업 길이 변화에 따른 SJF 및 FIFO 성능 비교

| 작업 길이       | SJF 응답 시간 | FIFO 응답 시간 | SJF 반환 시간 | FIFO 반환 시간 |
| --------------- | ------------- | -------------- | ------------- | -------------- |
| [100, 200, 300] | 300           | 400            | 900           | 1200           |

**분석**

- 작업 길이가 증가함에 따라 SJF와 FIFO의 응답 시간 및 반환 시간 차이가 더욱 커집니다.
- SJF는 여전히 FIFO보다 우수한 성능을 보여주지만, 작업 길이 변화에 민감하게 반응합니다.

## 3. RR 스케줄러 성능 (작업 길이 200, 3개 작업, 시간 할당량 1)

| 작업   | RR  |
| ------ | --- |
| 1      | 1   |
| 2      | 2   |
| 3      | 3   |
| **총** | 6   |

**분석**

- RR은 각 작업에 동일한 시간 할당량을 제공하기 때문에 응답 시간이 비교적 일정합니다.
- 하지만, SJF와 달리 작업 길이를 고려하지 않기 때문에 전체적인 효율성은 떨어질 수 있습니다.

## 4. SJF와 FIFO의 동일한 반환 시간 조건

- 작업 길이가 모두 동일한 경우, SJF와 FIFO는 동일한 반환 시간을 제공합니다.
- 이는 두 알고리즘 모두 작업 순서에 영향을 받지 않고 동일한 방식으로 처리하기 때문입니다.

## 5. SJF와 RR의 동일한 응답 시간 조건

- 작업 길이가 모두 동일하고 시간 할당량이 충분히 큰 경우, SJF와 RR은 동일한 응답 시간을 제공합니다.
- 이는 모든 작업이 시간 할당량 내에 완료될 수 있기 때문에 스케줄링 방식에 따른 차이가 발생하지 않기 때문입니다.

## 6. SJF 스케줄링에서 응답 시간의 변화

SJF 스케줄링에서는 항상 가장 짧은 작업이 먼저 실행됩니다. 이는 각 작업의 응답 시간이 그 작업 이전에 모든 더 짧은 작업들이 완료될 때까지의 시간이 됩니다. 따라서, 작업의 길이가 증가할수록, 그리고 작업의 순서가 뒤로 갈수록 응답 시간도 증가합니다.

예를 들어, 작업의 길이가 [5, 10, 20] 인 경우, 첫 번째 작업(길이 5)의 응답 시간은 0이고, 두 번째 작업(길이 10)의 응답 시간은 5(첫 번째 작업의 길이), 세 번째 작업(길이 20)의 응답 시간은 15(첫 번째와 두 번째 작업의 길이 합)가 됩니다.

```bash
# 시뮬레이션
python scheduler.py -s 123 -l 5,10,20 -p SJF -c
```

```bash
ARG policy SJF
ARG jlist 5,10,20

Here is the job list, with the run time of each job:
  Job 0 ( length = 5.0 )
  Job 1 ( length = 10.0 )
  Job 2 ( length = 20.0 )


** Solutions **

Execution trace:
  [ time   0 ] Run job 0 for 5.00 secs ( DONE at 5.00 )
  [ time   5 ] Run job 1 for 10.00 secs ( DONE at 15.00 )
  [ time  15 ] Run job 2 for 20.00 secs ( DONE at 35.00 )

Final statistics:
  Job   0 -- Response: 0.00  Turnaround 5.00  Wait 0.00
  Job   1 -- Response: 5.00  Turnaround 15.00  Wait 5.00
  Job   2 -- Response: 15.00  Turnaround 35.00  Wait 15.00

  Average -- Response: 6.67  Turnaround 18.33  Wait 6.67
```

## 7. 시간 할당량(time-slice)의 증가가 응답 시간에 미치는 영향과 최악의 경우

### RR 스케줄러에서 시간 할당량(time-slice)의 증가가 응답 시간에 미치는 영향

Round Robin(RR) 스케줄러에서 시간 할당량(quantum)은 각 작업이 CPU 시간을 할당받는 데에 사용되는 시간 단위입니다. 이 시간 할당량이 클수록 작업은 더 오랫동안 CPU를 점유하며 실행되고, 다른 작업들은 더 오래 대기하게 됩니다. 이는 특히 작업의 수가 많을 때 응답 시간을 증가시키는 원인이 됩니다.

### 최악의 응답 시간 수식

RR(Round Robin) 스케줄링에서 최악의 응답 시간은 특정 작업이 CPU를 처음으로 점유하기까지 걸리는 시간으로 정의됩니다. 이 시간은 주로 작업이 스케줄링 큐에서 어느 위치에 있느냐에 따라 달라집니다. 최악의 경우는 작업이 스케줄링 큐의 가장 마지막에 위치할 때 발생합니다.

주어진 작업 \( i \)의 최악의 응답 시간은 다음과 같이 계산할 수 있습니다.

\[ \text{Worst-case Response Time} = (N - 1) \times Q \]

- \( N \)은 작업의 총 수입니다.
- \( Q \)는 시간 할당량(time-slice)입니다.

이 공식은 각 작업이 최소 한 번씩 실행될 때까지의 시간을 고려합니다. 큐의 끝에 위치한 작업은 다른 모든 작업들이 각각 한 번씩 실행될 때까지 기다려야 하므로, 다른 모든 작업들이 \( Q \) 시간 동안 실행되는 것을 기다려야 합니다. 이는 최악의 시나리오에서 작업이 CPU에 접근하기 전에 발생하는 최대 대기 시간을 나타냅니다.

```{admonition} 예상 시뮬레이션 명령어
python scheduler.py -s 123 -j 3 -m 200 -p RR -q 1 -c
```
