# Week 7 Homework

## Q&A

1. 먼저 -n 10 -H 0 -p BEST -s 0 플래그로 실행하여 몇 개의 무작위 할당과 해제를 생성하세요.
alloc()/free()가 무엇을 반환할지 예측할 수 있나요? 
A: alloc()이 할당에 성공하면 할당된 메모리의 시작 주소를 반환하고, 실패하면 -1을 반환한다. 
free()는 성공하면 0을 반환하고, 실패하면 -1을 반환한다.
각 요청 후에 프리 리스트의 상태를 추측할 수 있나요? 
A:
1.할당: Alloc(6) - 프리 리스트에는 [addr:1000 sz:6]만 남아 있을 것으로 예상된다.
2.할당: Alloc(9) - 프리 리스트에는 [addr:1000 sz:6], [addr:1006 sz:9]가 남아 있을 것으로 예상된다.
3.할당: Alloc(7) - 프리 리스트에는 [addr:1000 sz:6], [addr:1006 sz:9], [addr:1015 sz:7]이 남아 있을 것으로 예상된다.
4.할당: Alloc(8) - 프리 리스트에는 [addr:1000 sz:6], [addr:1006 sz:9], [addr:1015 sz:7], [addr:1022 sz:8]이 남아 있을 것으로 예상된다.
5.해제: Free(ptr[3]) - 할당된 메모리 영역 [addr:1022 sz:8]이 프리 리스트에 추가될 것으로 예상된다.
6.할당: Alloc(1) - 프리 리스트에는 [addr:1000 sz:6], [addr:1006 sz:9], [addr:1015 sz:7], [addr:1030 sz:1], [addr:1022 sz:8]이 남아 있을 것으로 예상된다.
7.할당: Alloc(9) - 프리 리스트에는 [addr:1000 sz:6], [addr:1015 sz:7], [addr:1030 sz:1], [addr:1039 sz:9], [addr:1022 sz:8]이 남아 있을 것으로 예상된다.
8.해제: Free(ptr[1]) - 할당된 메모리 영역 [addr:1006 sz:9]가 프리 리스트에 추가될 것으로 예상된다.
9.할당: Alloc(7) - 프리 리스트에는 [addr:1000 sz:6], [addr:1015 sz:7], [addr:1030 sz:1], [addr:1039 sz:9], [addr:1022 sz:8]이 남아 있을 것으로 예상된다.
10.해제: Free(ptr[5]) - 할당된 메모리 영역 [addr:1031 sz:9]가 프리 리스트에 추가될 것으로 예상된다.
시간이 지남에 따라 프리 리스트에서 무엇을 알 수 있나요?
A:
1.할당과 해제 패턴: 시간이 지남에 따라 할당 및 해제 작업이 발생하는 패턴을 파악할 수 있다. 일정한 주기나 특정 이벤트에 따라 할당과 해제가 발생할 수 있다.
2.메모리 효율성: 프리 리스트의 상태를 모니터링하여 메모리 효율성을 평가할 수 있다. 프리 리스트에 남아 있는 조각들이 얼마나 큰지, 메모리 단편화가 어떤지 등을 파악할 수 있다.
3.할당 정책 평가: 프리 리스트의 상태를 통해 사용된 할당 정책의 효율성을 평가할 수 있다. 예를 들어, 프리 리스트가 길어지거나 메모리 단편화가 심해지는 경우 할당 정책을 개선해야 할 수도 있다.
4.성능 향상 기회: 프리 리스트의 상태를 모니터링하여 성능을 향상시킬 수 있는 기회를 발견할 수 있다. 예를 들어, 프리 리스트를 효율적으로 관리하거나 메모리 할당 알고리즘을 개선함으로써 성능을 향상시킬 수 있다.

2. 프리 리스트를 검색할 때 최악 적합(Worst-fit) 정책(-p WORST)을 사용하면 결과가 어떻게 달라지나요? 무엇이 바뀌나요?
A: 최악 적합(Worst-fit) 정책을 사용하면 프리 리스트를 검색할 때 가장 큰 메모리 블록을 선택하여 할당을 시도한다.
1.할당 과정: 최악 적합 정책을 사용하면 가능한 가장 큰 메모리 블록이 선택되어 할당된다. 작은 메모리 요청에 대해서도 큰 블록이 할당될 수 있다.
2.메모리 단편화: 큰 메모리 블록이 할당되기 때문에 메모리 단편화가 발생할 가능성이 높아진다. 작은 공간이 여러 개 있어도 최악 적합 정책은 가능한 가장 큰 공간을 선택하기 때문에 메모리 공간이 비효율적으로 사용될 수 있다.
3.프리 리스트의 변화: 할당과 해제 작업 후에도 프리 리스트의 상태가 변경된다. 최악 적합 정책을 사용하면 가장 큰 메모리 블록이 우선적으로 선택되어 제거되거나 분할될 수 있다.

3. 최선 적합(First-fit) 정책(-p FIRST)은 어떤가요?
A:
1.할당 과정: 최선 적합 정책은 가능한 가장 작은 메모리 블록을 선택하여 할당을 시도한다. 이는 현재 요청에 가장 적합한 메모리 블록을 찾아 할당됨을 의미한다.
2.메모리 단편화: 최선 적합 정책을 사용하면 가능한 작은 메모리 블록이 선택되므로, 메모리 단편화가 줄어든다. 더 많은 작은 메모리 조각이 재활용되어 메모리 효율성이 향상될 수 있다.
3.프리 리스트의 변화: 할당 및 해제 작업 후에도 프리 리스트의 상태가 변경된다. 최선 적합 정책을 사용하면 현재 요청에 가장 적합한 메모리 블록이 선택되어 할당되며, 메모리 블록이 분할되거나 재배치될 수 있다.
최선 적합을 사용하면 무엇이 빨라지나요?
A: 할당 시간, 메모리 검색 시간이 빨라진다. 

4. 위의 질문들에서, 리스트를 어떤 순서로 유지하느냐에 따라 일부 정책의 자유 블록 탐색 시간이 달라질 수 있습니다.
다양한 프리 리스트 순서(-l ADDRSORT,-l SIZESORT+,-l SIZESORT-)를 사용하여 정책과 리스트 순서가 어떻게 상호작용하는지 확인하세요.
A: 
ADDRSORT:
주소 순서대로 정렬된 리스트에서 최선 적합 정책을 사용하면, 할당 작업은 리스트의 맨 처음부터 시작하여 첫 번째로 맞는 블록을 찾는다. 이 경우 주소 순서에 따라 할당 시간에 영향을 미치지 않는다.
SIZESORT+:
크기가 오름차순으로 정렬된 리스트에서 최선 적합 정책을 사용하면, 할당 작업은 작은 블록부터 시작하여 첫 번째로 맞는 블록을 찾는다. 이는 메모리 블록의 크기 순서에 따라 할당 작업이 빠를 수 있다.
SIZESORT-:
크기가 내림차순으로 정렬된 리스트에서 최선 적합 정책을 사용하면, 할당 작업은 큰 블록부터 시작하여 첫 번째로 맞는 블록을 찾는다. 이 경우 큰 블록을 먼저 선택하므로 할당 시간이 상대적으로 느릴 수 있다.

5. 프리 리스트의 병합(Coalescing) 매우 중요할 수 있습니다. 무작위 할당 수를 늘려보세요(예: -n 1000). 
시간이 지남에 따라 큰 할당 요청에는 어떤 일이 일어나나요? 
A: 
메모리 단편화 증가: 큰 할당 요청이 자주 발생하면 메모리 공간이 조각조각으로 나누어져 메모리 단편화가 심해질 수 있다.
할당 시간 증가: 큰 할당 요청이 발생할 때는 보다 많은 프리 리스트를 검색해야 할 수 있으므로 할당 시간이 증가할 수 있다.
메모리 조각 조합: 프리 리스트에서 큰 메모리 조각을 찾지 못할 경우, 여러 작은 조각을 조합하여 요청한 크기의 메모리를 할당할 수 있다.
프리 리스트 관리: 할당 및 해제 작업이 지속됨에 따라 프리 리스트의 크기가 커질 수 있다.
병합 없이(즉, -C 플래그 없이) 그리고 병합과 함께 실행해 보세요. 결과에 어떤 차이가 있나요? 
A: 
병합을 사용하지 않은 경우:
프리 리스트에는 메모리 조각들이 분리되어 있다. 
할당 요청에 따라 작은 조각들이 할당되고 해제되면서 프리 리스트에 새로운 항목들이 계속 추가되어 이로 인해 메모리 단편화를 유발할 수 있다.
메모리 조각을 병합하는 추가 작업이 필요하지 않기 때문에 할당 및 해제 작업의 속도는 일반적으로 더 빠를 수 있다.
병합을 사용한 경우:
할당된 메모리 블록이 해제되면 인접한 블록들이 병합되어 더 큰 블록으로 만들어진다. 이는 메모리 단편화를 감소시키고 메모리 사용을 최적화하는 데 도움을 준다.
프리 리스트에는 병합된 큰 메모리 블록들이 추가되어 있다. 이는 할당 요청에 대해 더 큰 메모리 블록을 사용할 수 있음을 의미한다.
할당 및 해제 작업의 속도는 병합 작업 때문에 더 느릴 수 있다. 메모리 조각을 병합하는 과정이 추가되기 때문에 일반적으로 시간이 더 걸릴 수 있다.
각 경우에 시간에 따른 프리 리스트의 크기는 어떻게 되나요? 
A: 
병합을 사용하지 않은 경우:
할당된 메모리 블록이 해제되면 새로운 프리 리스트 항목으로 추가되고, 이로 인해 프리 리스트의 크기가 점진적으로 증가한다.
병합을 사용한 경우:
할당된 메모리 블록이 해제되면 인접한 블록들이 병합되어 더 큰 블록으로 만들어지고, 이로 인해 프리 리스트의 크기가 변동된다. 메모리 블록이 병합되면서 프리 리스트의 크기가 감소한다. 하지만 할당 작업에 따라 새로운 메모리 블록이 추가되어 다시 증가할 수도 있다.
이 경우 리스트의 순서가 중요한가요?
A: 병합을 사용하는 경우에는 ADDRSORT가 병합 작업의 효율성을 높이는 데 유리하고, 병합을 사용하지 않는 경우에는 할당 정책과 요청 패턴에 따라 적절한 리스트 순서를 선택하는 것이 중요하다.

6. 할당된 블록의 비율을 나타내는 -P를 50 이상으로 변경하면 어떻게 되나요?
A: 할당 요청의 비율을 높이면, 메모리 단편화가 증가하고 프리 리스트에 남아 있는 공간이 줄어든다.
할당 실패가 증가할 가능성이 있으며, 특히 큰 블록의 할당 요청이 실패할 수 있다.
병합을 사용하는 경우, 단편화를 줄이고 할당 실패를 줄일 수 있지만, 병합 작업의 오버헤드가 발생할 수 있다.
이 비율이 100에 가까워지면 할당은 어떻게 되나요? 
A: 할당 요청이 압도적으로 많아져 프리 리스트의 메모리 블록이 빠르게 소모된다.
프리 리스트에 남아있는 메모리 블록이 줄어들면서 할당 실패가 빈번해진다.
메모리 단편화는 해제가 거의 없기 때문에 상대적으로 덜 중요하지만, 이는 프리 리스트에 남아있는 조각들이 거의 없기 때문이다.
결국, 시스템이 메모리 부족 상태에 이를 수 있다.
0에 가까워지면요?
A: 시스템이 메모리 해제를 주로 처리하게 되어 프리 리스트가 증가하고, 메모리 단편화가 감소하며, 할당 실패가 거의 발생하지 않는 상태가 된다.

7. 고도로 단편화된 프리 공간을 생성하려면 어떤 종류의 특정 요청을 만들 수 있나요? 
A: 
작은 블록과 큰 블록 혼합:
할당: 작은 블록 여러 개
할당: 큰 블록 하나
해제: 작은 블록 여러 개

교차 패턴 할당 및 해제:
할당: 블록 여러 개
해제: 일부 블록
할당: 다른 블록
해제: 나머지 블록

주기적인 큰 블록 해제 후 작은 블록 할당:
할당: 큰 블록 여러 개
해제: 일부 큰 블록
할당: 작은 블록 여러 개

불규칙한 해제:
할당: 블록 여러 개
해제: 불규칙하게 여러 블록

이런 패턴을 사용하면 메모리 공간이 잘게 나뉘어져 단편화가 발생한다. 
-A 플래그를 사용하여 단편화된 프리 리스트를 생성하고, 다양한 정책과 옵션이 프리 리스트의 구성을 어떻게 변경하는지 확인하세요.
A: 
1.BEST-FIT 정책 (-p BEST)
이 정책은 가장 작은 적합 블록을 선택한다. 이 경우 단편화가 적을 수 있지만, 프리 리스트가 작은 조각들로 가득찰 수 있다.
2.WORST-FIT 정책 (-p WORST)
이 정책은 가장 큰 적합 블록을 선택한다. 이 경우 단편화가 더 많이 발생할 수 있다.
3.FIRST-FIT 정책 (-p FIRST)
이 정책은 처음으로 적합한 블록을 선택한다. 이 경우 할당이 빠르게 이루어지지만, 단편화가 발생할 수 있다.
4.COALESCE 옵션 (-C)
병합 옵션을 활성화하면 인접한 프리 블록이 병합되어 단편화를 줄일 수 있다.
5.프리 리스트 순서 변경 (-l)
프리 리스트 순서 옵션을 사용하여 블록 정렬 방식을 변경할 수 있다. 예를 들어, 주소 순서로 정렬하거나, 블록 크기 순서로 정렬하는 등의 옵션이 있다.
이와 같은 설정으로 프로그램을 실행한 후 프리 리스트의 상태를 관찰하여 각 정책 및 옵션이 단편화 및 프리 리스트 구성에 어떻게 영향을 미치는지 확인할 수 있다. -C 옵션을 사용하면 병합이 어떻게 단편화를 줄이는지, -l 옵션을 사용하면 리스트 정렬 순서가 할당 효율성에 어떻게 영향을 미치는지 등을 알 수 있다.
