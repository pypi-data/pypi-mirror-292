# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities

__all__ = [
    'ApiKeyPermissionsArgs',
    'BurnAlertRecipientArgs',
    'BurnAlertRecipientNotificationDetailsArgs',
    'GetAuthMetadataApiKeyAccessArgs',
    'GetAuthMetadataEnvironmentArgs',
    'GetAuthMetadataTeamArgs',
    'GetDatasetsDetailFilterArgs',
    'GetEnvironmentsDetailFilterArgs',
    'GetQuerySpecificationCalculationArgs',
    'GetQuerySpecificationFilterArgs',
    'GetQuerySpecificationHavingArgs',
    'GetQuerySpecificationOrderArgs',
    'GetSLOsDetailFilterArgs',
    'TriggerEvaluationScheduleArgs',
    'TriggerRecipientArgs',
    'TriggerRecipientNotificationDetailsArgs',
    'TriggerThresholdArgs',
]

@pulumi.input_type
class ApiKeyPermissionsArgs:
    def __init__(__self__, *,
                 create_datasets: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] create_datasets: Allow this key to create missing datasets when sending telemetry. Defaults to `false`.
        """
        if create_datasets is not None:
            pulumi.set(__self__, "create_datasets", create_datasets)

    @property
    @pulumi.getter(name="createDatasets")
    def create_datasets(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow this key to create missing datasets when sending telemetry. Defaults to `false`.
        """
        return pulumi.get(self, "create_datasets")

    @create_datasets.setter
    def create_datasets(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "create_datasets", value)


@pulumi.input_type
class BurnAlertRecipientArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 notification_details: Optional[pulumi.Input['BurnAlertRecipientNotificationDetailsArgs']] = None,
                 target: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: The ID of an already existing recipient. Should not be used in combination with `type` and `target`.
        :param pulumi.Input['BurnAlertRecipientNotificationDetailsArgs'] notification_details: a block of additional details to send along with the notification. The only supported option currently is `pagerduty_severity` which has a default value of `critical` but can be set to one of `info`, `warning`, `error`, or `critical` and must be used in combination with a PagerDuty recipient.
               
               | Type      | Target              |
               |-----------|---------------------|
               | email     | an email address    |
               | pagerduty | _N/A_               |
               | slack     | name of the channel |
               | webhook   | name of the webhook |
        :param pulumi.Input[str] target: Target of the recipient, this has another meaning depending on the type of recipient (see the table below). Should not be used in combination with `id`.
        :param pulumi.Input[str] type: The type of the recipient, allowed types are `email`, `pagerduty`, `msteams`, `slack` and `webhook`. Should not be used in combination with `id`.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if notification_details is not None:
            pulumi.set(__self__, "notification_details", notification_details)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of an already existing recipient. Should not be used in combination with `type` and `target`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="notificationDetails")
    def notification_details(self) -> Optional[pulumi.Input['BurnAlertRecipientNotificationDetailsArgs']]:
        """
        a block of additional details to send along with the notification. The only supported option currently is `pagerduty_severity` which has a default value of `critical` but can be set to one of `info`, `warning`, `error`, or `critical` and must be used in combination with a PagerDuty recipient.

        | Type      | Target              |
        |-----------|---------------------|
        | email     | an email address    |
        | pagerduty | _N/A_               |
        | slack     | name of the channel |
        | webhook   | name of the webhook |
        """
        return pulumi.get(self, "notification_details")

    @notification_details.setter
    def notification_details(self, value: Optional[pulumi.Input['BurnAlertRecipientNotificationDetailsArgs']]):
        pulumi.set(self, "notification_details", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[str]]:
        """
        Target of the recipient, this has another meaning depending on the type of recipient (see the table below). Should not be used in combination with `id`.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of the recipient, allowed types are `email`, `pagerduty`, `msteams`, `slack` and `webhook`. Should not be used in combination with `id`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class BurnAlertRecipientNotificationDetailsArgs:
    def __init__(__self__, *,
                 pagerduty_severity: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] pagerduty_severity: The severity to set with the PagerDuty notification. If no severity is provided, 'critical' is assumed.
        """
        if pagerduty_severity is not None:
            pulumi.set(__self__, "pagerduty_severity", pagerduty_severity)

    @property
    @pulumi.getter(name="pagerdutySeverity")
    def pagerduty_severity(self) -> Optional[pulumi.Input[str]]:
        """
        The severity to set with the PagerDuty notification. If no severity is provided, 'critical' is assumed.
        """
        return pulumi.get(self, "pagerduty_severity")

    @pagerduty_severity.setter
    def pagerduty_severity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pagerduty_severity", value)


@pulumi.input_type
class GetAuthMetadataApiKeyAccessArgs:
    def __init__(__self__, *,
                 boards: bool,
                 columns: bool,
                 datasets: bool,
                 events: bool,
                 markers: bool,
                 queries: bool,
                 recipients: bool,
                 slos: bool,
                 triggers: bool):
        """
        :param bool boards: `true` if this API key can create and manage Boards.
        :param bool columns: `true` if this API key can create and manage can create and manage Queries, Columns, Derived Columns, and Query Annotations
        :param bool datasets: `true` if this API key can create and manage Datasets.
        :param bool events: `true` if this API key can key can send events to Honeycomb.
        :param bool markers: `true` if this API key can create and manage Markers.
        :param bool queries: `true` if this API key can execute existing Queries via the Query Data API.
        :param bool recipients: `true` if this API key can create and manage Recipients.
        :param bool slos: `true` if this API key can create and manage SLOs.
        :param bool triggers: `true` if this API key can create and manage Triggers.
        """
        pulumi.set(__self__, "boards", boards)
        pulumi.set(__self__, "columns", columns)
        pulumi.set(__self__, "datasets", datasets)
        pulumi.set(__self__, "events", events)
        pulumi.set(__self__, "markers", markers)
        pulumi.set(__self__, "queries", queries)
        pulumi.set(__self__, "recipients", recipients)
        pulumi.set(__self__, "slos", slos)
        pulumi.set(__self__, "triggers", triggers)

    @property
    @pulumi.getter
    def boards(self) -> bool:
        """
        `true` if this API key can create and manage Boards.
        """
        return pulumi.get(self, "boards")

    @boards.setter
    def boards(self, value: bool):
        pulumi.set(self, "boards", value)

    @property
    @pulumi.getter
    def columns(self) -> bool:
        """
        `true` if this API key can create and manage can create and manage Queries, Columns, Derived Columns, and Query Annotations
        """
        return pulumi.get(self, "columns")

    @columns.setter
    def columns(self, value: bool):
        pulumi.set(self, "columns", value)

    @property
    @pulumi.getter
    def datasets(self) -> bool:
        """
        `true` if this API key can create and manage Datasets.
        """
        return pulumi.get(self, "datasets")

    @datasets.setter
    def datasets(self, value: bool):
        pulumi.set(self, "datasets", value)

    @property
    @pulumi.getter
    def events(self) -> bool:
        """
        `true` if this API key can key can send events to Honeycomb.
        """
        return pulumi.get(self, "events")

    @events.setter
    def events(self, value: bool):
        pulumi.set(self, "events", value)

    @property
    @pulumi.getter
    def markers(self) -> bool:
        """
        `true` if this API key can create and manage Markers.
        """
        return pulumi.get(self, "markers")

    @markers.setter
    def markers(self, value: bool):
        pulumi.set(self, "markers", value)

    @property
    @pulumi.getter
    def queries(self) -> bool:
        """
        `true` if this API key can execute existing Queries via the Query Data API.
        """
        return pulumi.get(self, "queries")

    @queries.setter
    def queries(self, value: bool):
        pulumi.set(self, "queries", value)

    @property
    @pulumi.getter
    def recipients(self) -> bool:
        """
        `true` if this API key can create and manage Recipients.
        """
        return pulumi.get(self, "recipients")

    @recipients.setter
    def recipients(self, value: bool):
        pulumi.set(self, "recipients", value)

    @property
    @pulumi.getter
    def slos(self) -> bool:
        """
        `true` if this API key can create and manage SLOs.
        """
        return pulumi.get(self, "slos")

    @slos.setter
    def slos(self, value: bool):
        pulumi.set(self, "slos", value)

    @property
    @pulumi.getter
    def triggers(self) -> bool:
        """
        `true` if this API key can create and manage Triggers.
        """
        return pulumi.get(self, "triggers")

    @triggers.setter
    def triggers(self, value: bool):
        pulumi.set(self, "triggers", value)


@pulumi.input_type
class GetAuthMetadataEnvironmentArgs:
    def __init__(__self__, *,
                 classic: bool,
                 name: str,
                 slug: str):
        """
        :param bool classic: `true` if this API key belongs to a [Honeycomb Classic](https://docs.honeycomb.io/honeycomb-classic/) environment.
        :param str name: The name of the Team.
        :param str slug: The slug of the Team.
        """
        pulumi.set(__self__, "classic", classic)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "slug", slug)

    @property
    @pulumi.getter
    def classic(self) -> bool:
        """
        `true` if this API key belongs to a [Honeycomb Classic](https://docs.honeycomb.io/honeycomb-classic/) environment.
        """
        return pulumi.get(self, "classic")

    @classic.setter
    def classic(self, value: bool):
        pulumi.set(self, "classic", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Team.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def slug(self) -> str:
        """
        The slug of the Team.
        """
        return pulumi.get(self, "slug")

    @slug.setter
    def slug(self, value: str):
        pulumi.set(self, "slug", value)


@pulumi.input_type
class GetAuthMetadataTeamArgs:
    def __init__(__self__, *,
                 name: str,
                 slug: str):
        """
        :param str name: The name of the Team.
        :param str slug: The slug of the Team.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "slug", slug)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Team.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def slug(self) -> str:
        """
        The slug of the Team.
        """
        return pulumi.get(self, "slug")

    @slug.setter
    def slug(self, value: str):
        pulumi.set(self, "slug", value)


@pulumi.input_type
class GetDatasetsDetailFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 value: Optional[str] = None,
                 value_regex: Optional[str] = None):
        """
        :param str name: The name of the detail field to filter by. Currently only `name` is supported.
        :param str value: The value of the detail field to match on.
        :param str value_regex: A regular expression string to apply to the value of the detail field to match on.
               
               > **Note** one of `value` or `value_regex` is required.
        """
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_regex is not None:
            pulumi.set(__self__, "value_regex", value_regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the detail field to filter by. Currently only `name` is supported.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the detail field to match on.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="valueRegex")
    def value_regex(self) -> Optional[str]:
        """
        A regular expression string to apply to the value of the detail field to match on.

        > **Note** one of `value` or `value_regex` is required.
        """
        return pulumi.get(self, "value_regex")

    @value_regex.setter
    def value_regex(self, value: Optional[str]):
        pulumi.set(self, "value_regex", value)


@pulumi.input_type
class GetEnvironmentsDetailFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 value: Optional[str] = None,
                 value_regex: Optional[str] = None):
        """
        :param str name: The name of the detail field to filter by. Currently only `name` is supported.
        :param str value: The value of the detail field to match on.
        :param str value_regex: A regular expression string to apply to the value of the detail field to match on.
               
               > **Note** one of `value` or `value_regex` is required.
        """
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_regex is not None:
            pulumi.set(__self__, "value_regex", value_regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the detail field to filter by. Currently only `name` is supported.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the detail field to match on.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="valueRegex")
    def value_regex(self) -> Optional[str]:
        """
        A regular expression string to apply to the value of the detail field to match on.

        > **Note** one of `value` or `value_regex` is required.
        """
        return pulumi.get(self, "value_regex")

    @value_regex.setter
    def value_regex(self, value: Optional[str]):
        pulumi.set(self, "value_regex", value)


@pulumi.input_type
class GetQuerySpecificationCalculationArgs:
    def __init__(__self__, *,
                 op: str,
                 column: Optional[str] = None):
        """
        :param str op: The operator to apply, see the supported list of calculation operators at [Calculation Operators](https://docs.honeycomb.io/api/query-specification/#calculation-operators).
        :param str column: The column to apply the operator to, not needed with `COUNT` or `CONCURRENCY`.
        """
        pulumi.set(__self__, "op", op)
        if column is not None:
            pulumi.set(__self__, "column", column)

    @property
    @pulumi.getter
    def op(self) -> str:
        """
        The operator to apply, see the supported list of calculation operators at [Calculation Operators](https://docs.honeycomb.io/api/query-specification/#calculation-operators).
        """
        return pulumi.get(self, "op")

    @op.setter
    def op(self, value: str):
        pulumi.set(self, "op", value)

    @property
    @pulumi.getter
    def column(self) -> Optional[str]:
        """
        The column to apply the operator to, not needed with `COUNT` or `CONCURRENCY`.
        """
        return pulumi.get(self, "column")

    @column.setter
    def column(self, value: Optional[str]):
        pulumi.set(self, "column", value)


@pulumi.input_type
class GetQuerySpecificationFilterArgs:
    def __init__(__self__, *,
                 column: str,
                 op: str,
                 value: Optional[str] = None):
        """
        :param str column: The column to apply the filter to.
        :param str op: The operator to apply, see the supported list of filter operators at [Filter Operators](https://docs.honeycomb.io/api/query-specification/#filter-operators). Not all operators require a value.
        :param str value: The value used for the filter. Not needed if op is `exists` or `not-exists`. Mutually exclusive with the other `value_*` options.
               
               * > **NOTE** Filter op `in` and `not-in` expect an array of strings as value. Use the `value` attribute and pass the values in single string separated by `,` without additional spaces (similar to the query builder in the UI). For example: the list `foo`, `bar` becomes `foo,bar`.
        """
        pulumi.set(__self__, "column", column)
        pulumi.set(__self__, "op", op)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def column(self) -> str:
        """
        The column to apply the filter to.
        """
        return pulumi.get(self, "column")

    @column.setter
    def column(self, value: str):
        pulumi.set(self, "column", value)

    @property
    @pulumi.getter
    def op(self) -> str:
        """
        The operator to apply, see the supported list of filter operators at [Filter Operators](https://docs.honeycomb.io/api/query-specification/#filter-operators). Not all operators require a value.
        """
        return pulumi.get(self, "op")

    @op.setter
    def op(self, value: str):
        pulumi.set(self, "op", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value used for the filter. Not needed if op is `exists` or `not-exists`. Mutually exclusive with the other `value_*` options.

        * > **NOTE** Filter op `in` and `not-in` expect an array of strings as value. Use the `value` attribute and pass the values in single string separated by `,` without additional spaces (similar to the query builder in the UI). For example: the list `foo`, `bar` becomes `foo,bar`.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class GetQuerySpecificationHavingArgs:
    def __init__(__self__, *,
                 calculate_op: str,
                 op: str,
                 value: float,
                 column: Optional[str] = None):
        """
        :param str calculate_op: The calculation operator to apply, supports all of the [Calculation Operators](https://docs.honeycomb.io/api/query-specification/#calculation-operators) with the exception of `HEATMAP`.
        :param str op: The operator to apply to filter the query results. One of `=`, `!=`, `>`, `>=`, `<`, or `<=`.
        :param float value: The value used with `op`. Currently assumed to be a number.
               
               > **NOTE** A having term's `column`/`calculate_op` pair must have a corresponding `calculation`. There can be multiple `having` blocks for the same `column`/`calculate_op` pair.
        :param str column: The column to apply the `calculate_op` to, not needed with `COUNT` or `CONCURRENCY`.
        """
        pulumi.set(__self__, "calculate_op", calculate_op)
        pulumi.set(__self__, "op", op)
        pulumi.set(__self__, "value", value)
        if column is not None:
            pulumi.set(__self__, "column", column)

    @property
    @pulumi.getter(name="calculateOp")
    def calculate_op(self) -> str:
        """
        The calculation operator to apply, supports all of the [Calculation Operators](https://docs.honeycomb.io/api/query-specification/#calculation-operators) with the exception of `HEATMAP`.
        """
        return pulumi.get(self, "calculate_op")

    @calculate_op.setter
    def calculate_op(self, value: str):
        pulumi.set(self, "calculate_op", value)

    @property
    @pulumi.getter
    def op(self) -> str:
        """
        The operator to apply to filter the query results. One of `=`, `!=`, `>`, `>=`, `<`, or `<=`.
        """
        return pulumi.get(self, "op")

    @op.setter
    def op(self, value: str):
        pulumi.set(self, "op", value)

    @property
    @pulumi.getter
    def value(self) -> float:
        """
        The value used with `op`. Currently assumed to be a number.

        > **NOTE** A having term's `column`/`calculate_op` pair must have a corresponding `calculation`. There can be multiple `having` blocks for the same `column`/`calculate_op` pair.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: float):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def column(self) -> Optional[str]:
        """
        The column to apply the `calculate_op` to, not needed with `COUNT` or `CONCURRENCY`.
        """
        return pulumi.get(self, "column")

    @column.setter
    def column(self, value: Optional[str]):
        pulumi.set(self, "column", value)


@pulumi.input_type
class GetQuerySpecificationOrderArgs:
    def __init__(__self__, *,
                 column: Optional[str] = None,
                 op: Optional[str] = None,
                 order: Optional[str] = None):
        """
        :param str column: Either a column present in `breakdown` or a column that `op` applies to.
        :param str op: The calculation operator to apply, see the supported list of calculation operators at [Calculation Operators](https://docs.honeycomb.io/api/query-specification/#calculation-operators).
        :param str order: The sort direction, if set must be `ascending` or `descending`.
        """
        if column is not None:
            pulumi.set(__self__, "column", column)
        if op is not None:
            pulumi.set(__self__, "op", op)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def column(self) -> Optional[str]:
        """
        Either a column present in `breakdown` or a column that `op` applies to.
        """
        return pulumi.get(self, "column")

    @column.setter
    def column(self, value: Optional[str]):
        pulumi.set(self, "column", value)

    @property
    @pulumi.getter
    def op(self) -> Optional[str]:
        """
        The calculation operator to apply, see the supported list of calculation operators at [Calculation Operators](https://docs.honeycomb.io/api/query-specification/#calculation-operators).
        """
        return pulumi.get(self, "op")

    @op.setter
    def op(self, value: Optional[str]):
        pulumi.set(self, "op", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        The sort direction, if set must be `ascending` or `descending`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[str]):
        pulumi.set(self, "order", value)


@pulumi.input_type
class GetSLOsDetailFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 value: Optional[str] = None,
                 value_regex: Optional[str] = None):
        """
        :param str name: The name of the detail field to filter by. Currently only `name` is supported.
        :param str value: The value of the detail field to match on.
        :param str value_regex: A regular expression string to apply to the value of the detail field to match on.
               
               > **Note** one of `value` or `value_regex` is required.
        """
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_regex is not None:
            pulumi.set(__self__, "value_regex", value_regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the detail field to filter by. Currently only `name` is supported.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the detail field to match on.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="valueRegex")
    def value_regex(self) -> Optional[str]:
        """
        A regular expression string to apply to the value of the detail field to match on.

        > **Note** one of `value` or `value_regex` is required.
        """
        return pulumi.get(self, "value_regex")

    @value_regex.setter
    def value_regex(self, value: Optional[str]):
        pulumi.set(self, "value_regex", value)


@pulumi.input_type
class TriggerEvaluationScheduleArgs:
    def __init__(__self__, *,
                 days_of_weeks: pulumi.Input[Sequence[pulumi.Input[str]]],
                 end_time: pulumi.Input[str],
                 start_time: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] days_of_weeks: A list of days of the week (in lowercase) to evaluate the trigger on
        :param pulumi.Input[str] end_time: UTC time to stop evaluating the trigger in HH:mm format (e.g. `13:00`)
        :param pulumi.Input[str] start_time: UTC time to start evaluating the trigger in HH:mm format (e.g. `13:00`)
        """
        pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of days of the week (in lowercase) to evaluate the trigger on
        """
        return pulumi.get(self, "days_of_weeks")

    @days_of_weeks.setter
    def days_of_weeks(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "days_of_weeks", value)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> pulumi.Input[str]:
        """
        UTC time to stop evaluating the trigger in HH:mm format (e.g. `13:00`)
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "end_time", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> pulumi.Input[str]:
        """
        UTC time to start evaluating the trigger in HH:mm format (e.g. `13:00`)
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_time", value)


@pulumi.input_type
class TriggerRecipientArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 notification_details: Optional[pulumi.Input['TriggerRecipientNotificationDetailsArgs']] = None,
                 target: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: The ID of an already existing recipient. Cannot not be used in combination with `type` and `target`.
        :param pulumi.Input['TriggerRecipientNotificationDetailsArgs'] notification_details: a block of additional details to send along with the notification. The only supported option currently is `pagerduty_severity` which has a default value of `critical` but can be set to one of `info`, `warning`, `error`, or `critical` and must be used in combination with a PagerDuty recipient.
               
               Type      | Target
               ----------|-------------------------
               email     | an email address
               marker    | name of the marker
               pagerduty | _N/A_
               slack     | name of the channel
               webhook   | name of the webhook
        :param pulumi.Input[str] target: Target of the trigger recipient, this has another meaning depending on the type of recipient (see the table below).
               Cannot not be used in combination with `id`.
        :param pulumi.Input[str] type: The type of the trigger recipient, allowed types are `email`, `marker`, `msteams`, `pagerduty`, `slack` and `webhook`.
               Cannot not be used in combination with `id`.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if notification_details is not None:
            pulumi.set(__self__, "notification_details", notification_details)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of an already existing recipient. Cannot not be used in combination with `type` and `target`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="notificationDetails")
    def notification_details(self) -> Optional[pulumi.Input['TriggerRecipientNotificationDetailsArgs']]:
        """
        a block of additional details to send along with the notification. The only supported option currently is `pagerduty_severity` which has a default value of `critical` but can be set to one of `info`, `warning`, `error`, or `critical` and must be used in combination with a PagerDuty recipient.

        Type      | Target
        ----------|-------------------------
        email     | an email address
        marker    | name of the marker
        pagerduty | _N/A_
        slack     | name of the channel
        webhook   | name of the webhook
        """
        return pulumi.get(self, "notification_details")

    @notification_details.setter
    def notification_details(self, value: Optional[pulumi.Input['TriggerRecipientNotificationDetailsArgs']]):
        pulumi.set(self, "notification_details", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[str]]:
        """
        Target of the trigger recipient, this has another meaning depending on the type of recipient (see the table below).
        Cannot not be used in combination with `id`.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of the trigger recipient, allowed types are `email`, `marker`, `msteams`, `pagerduty`, `slack` and `webhook`.
        Cannot not be used in combination with `id`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class TriggerRecipientNotificationDetailsArgs:
    def __init__(__self__, *,
                 pagerduty_severity: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] pagerduty_severity: The severity to set with the PagerDuty notification. If no severity is provided, 'critical' is assumed.
        """
        if pagerduty_severity is not None:
            pulumi.set(__self__, "pagerduty_severity", pagerduty_severity)

    @property
    @pulumi.getter(name="pagerdutySeverity")
    def pagerduty_severity(self) -> Optional[pulumi.Input[str]]:
        """
        The severity to set with the PagerDuty notification. If no severity is provided, 'critical' is assumed.
        """
        return pulumi.get(self, "pagerduty_severity")

    @pagerduty_severity.setter
    def pagerduty_severity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pagerduty_severity", value)


@pulumi.input_type
class TriggerThresholdArgs:
    def __init__(__self__, *,
                 op: pulumi.Input[str],
                 value: pulumi.Input[float],
                 exceeded_limit: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] op: The operator to apply, allowed threshold operators are `>`, `>=`, `<`, and `<=`.
        :param pulumi.Input[float] value: The value to be used with the operator.
        :param pulumi.Input[int] exceeded_limit: The number of times the threshold is met before an alert is sent, must be between 1 and 5. Defaults to `1`.
        """
        pulumi.set(__self__, "op", op)
        pulumi.set(__self__, "value", value)
        if exceeded_limit is not None:
            pulumi.set(__self__, "exceeded_limit", exceeded_limit)

    @property
    @pulumi.getter
    def op(self) -> pulumi.Input[str]:
        """
        The operator to apply, allowed threshold operators are `>`, `>=`, `<`, and `<=`.
        """
        return pulumi.get(self, "op")

    @op.setter
    def op(self, value: pulumi.Input[str]):
        pulumi.set(self, "op", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        """
        The value to be used with the operator.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="exceededLimit")
    def exceeded_limit(self) -> Optional[pulumi.Input[int]]:
        """
        The number of times the threshold is met before an alert is sent, must be between 1 and 5. Defaults to `1`.
        """
        return pulumi.get(self, "exceeded_limit")

    @exceeded_limit.setter
    def exceeded_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "exceeded_limit", value)


