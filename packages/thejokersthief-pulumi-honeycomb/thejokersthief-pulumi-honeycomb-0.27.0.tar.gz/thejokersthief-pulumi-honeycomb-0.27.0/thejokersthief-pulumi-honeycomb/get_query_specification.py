# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs
from ._inputs import *

__all__ = [
    'GetQuerySpecificationResult',
    'AwaitableGetQuerySpecificationResult',
    'get_query_specification',
    'get_query_specification_output',
]

@pulumi.output_type
class GetQuerySpecificationResult:
    """
    A collection of values returned by GetQuerySpecification.
    """
    def __init__(__self__, breakdowns=None, calculations=None, end_time=None, filter_combination=None, filters=None, granularity=None, havings=None, id=None, json=None, limit=None, orders=None, start_time=None, time_range=None):
        if breakdowns and not isinstance(breakdowns, list):
            raise TypeError("Expected argument 'breakdowns' to be a list")
        pulumi.set(__self__, "breakdowns", breakdowns)
        if calculations and not isinstance(calculations, list):
            raise TypeError("Expected argument 'calculations' to be a list")
        pulumi.set(__self__, "calculations", calculations)
        if end_time and not isinstance(end_time, int):
            raise TypeError("Expected argument 'end_time' to be a int")
        pulumi.set(__self__, "end_time", end_time)
        if filter_combination and not isinstance(filter_combination, str):
            raise TypeError("Expected argument 'filter_combination' to be a str")
        pulumi.set(__self__, "filter_combination", filter_combination)
        if filters and not isinstance(filters, list):
            raise TypeError("Expected argument 'filters' to be a list")
        pulumi.set(__self__, "filters", filters)
        if granularity and not isinstance(granularity, int):
            raise TypeError("Expected argument 'granularity' to be a int")
        pulumi.set(__self__, "granularity", granularity)
        if havings and not isinstance(havings, list):
            raise TypeError("Expected argument 'havings' to be a list")
        pulumi.set(__self__, "havings", havings)
        if id and not isinstance(id, str):
            raise TypeError("Expected argument 'id' to be a str")
        pulumi.set(__self__, "id", id)
        if json and not isinstance(json, str):
            raise TypeError("Expected argument 'json' to be a str")
        pulumi.set(__self__, "json", json)
        if limit and not isinstance(limit, int):
            raise TypeError("Expected argument 'limit' to be a int")
        pulumi.set(__self__, "limit", limit)
        if orders and not isinstance(orders, list):
            raise TypeError("Expected argument 'orders' to be a list")
        pulumi.set(__self__, "orders", orders)
        if start_time and not isinstance(start_time, int):
            raise TypeError("Expected argument 'start_time' to be a int")
        pulumi.set(__self__, "start_time", start_time)
        if time_range and not isinstance(time_range, int):
            raise TypeError("Expected argument 'time_range' to be a int")
        pulumi.set(__self__, "time_range", time_range)

    @property
    @pulumi.getter
    def breakdowns(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "breakdowns")

    @property
    @pulumi.getter
    def calculations(self) -> Optional[Sequence['outputs.GetQuerySpecificationCalculationResult']]:
        return pulumi.get(self, "calculations")

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[int]:
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter(name="filterCombination")
    def filter_combination(self) -> Optional[str]:
        return pulumi.get(self, "filter_combination")

    @property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.GetQuerySpecificationFilterResult']]:
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter
    def granularity(self) -> Optional[int]:
        return pulumi.get(self, "granularity")

    @property
    @pulumi.getter
    def havings(self) -> Optional[Sequence['outputs.GetQuerySpecificationHavingResult']]:
        return pulumi.get(self, "havings")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The `id` attribute is deprecated and included for compatibility with the Terraform Plugin SDK. It will be removed in a future version.""")
    def id(self) -> str:
        """
        ID of the query specification.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def json(self) -> str:
        """
        JSON representation of the query according to the [Query Specification](https://docs.honeycomb.io/api/query-specification/#fields-on-a-query-specification), can be used as input for other resources.
        """
        return pulumi.get(self, "json")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def orders(self) -> Optional[Sequence['outputs.GetQuerySpecificationOrderResult']]:
        return pulumi.get(self, "orders")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[int]:
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter(name="timeRange")
    def time_range(self) -> Optional[int]:
        return pulumi.get(self, "time_range")


class AwaitableGetQuerySpecificationResult(GetQuerySpecificationResult):
    # pylint: disable=using-constant-test
    def __await__(self):
        if False:
            yield self
        return GetQuerySpecificationResult(
            breakdowns=self.breakdowns,
            calculations=self.calculations,
            end_time=self.end_time,
            filter_combination=self.filter_combination,
            filters=self.filters,
            granularity=self.granularity,
            havings=self.havings,
            id=self.id,
            json=self.json,
            limit=self.limit,
            orders=self.orders,
            start_time=self.start_time,
            time_range=self.time_range)


def get_query_specification(breakdowns: Optional[Sequence[str]] = None,
                            calculations: Optional[Sequence[Union['GetQuerySpecificationCalculationArgs', 'GetQuerySpecificationCalculationArgsDict']]] = None,
                            end_time: Optional[int] = None,
                            filter_combination: Optional[str] = None,
                            filters: Optional[Sequence[Union['GetQuerySpecificationFilterArgs', 'GetQuerySpecificationFilterArgsDict']]] = None,
                            granularity: Optional[int] = None,
                            havings: Optional[Sequence[Union['GetQuerySpecificationHavingArgs', 'GetQuerySpecificationHavingArgsDict']]] = None,
                            limit: Optional[int] = None,
                            orders: Optional[Sequence[Union['GetQuerySpecificationOrderArgs', 'GetQuerySpecificationOrderArgsDict']]] = None,
                            start_time: Optional[int] = None,
                            time_range: Optional[int] = None,
                            opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetQuerySpecificationResult:
    """
    ## # Data Source: get_query_specification

    Generates a [Query Specification](https://docs.honeycomb.io/api/query-specification/) in JSON format for use with resources that expect a JSON-formatted Query Specification like `Query`.

    Using this data source to generate query specifications is optional.
    It is also valid to use literal JSON strings in your configuration or to use the file interpolation function to read a raw JSON query specification from a file.

    ## Example Usage

    ```python
    import pulumi
    import pulumi_honeycomb as honeycomb

    example = honeycomb.get_query_specification(calculations=[{
            "op": "AVG",
            "column": "duration_ms",
        }],
        filters=[
            {
                "column": "trace.parent_id",
                "op": "does-not-exist",
            },
            {
                "column": "app.tenant",
                "op": "=",
                "value": "ThatSpecialTenant",
            },
        ],
        filter_combination="AND",
        breakdowns=["app.tenant"],
        time_range=28800)
    pulumi.export("jsonQuery", example.json)
    ```


    :param Sequence[str] breakdowns: A list of fields to group by.
    :param Sequence[Union['GetQuerySpecificationCalculationArgs', 'GetQuerySpecificationCalculationArgsDict']] calculations: Zero or more configuration blocks (described below) with the calculations that should be displayed. If no calculations are specified, `COUNT` will be used.
    :param int end_time: The absolute end time of the query in Unix Time (= seconds since epoch).
    :param str filter_combination: How to combine multiple filters, either `AND` (default) or `OR`.
    :param Sequence[Union['GetQuerySpecificationFilterArgs', 'GetQuerySpecificationFilterArgsDict']] filters: Zero or more configuration blocks (described below) with the filters that should be applied.
    :param int granularity: The time resolution of the query’s graph, in seconds. Valid values must be in between the query’s time range /10 at maximum, and /1000 at minimum.
           
           > **NOTE** It is not allowed to specify all three of `time_range`, `start_time` and `end_time`. For more details about specifying time windows, check [Query specification: A caveat on time](https://docs.honeycomb.io/api/query-specification/#a-caveat-on-time).
    :param Sequence[Union['GetQuerySpecificationHavingArgs', 'GetQuerySpecificationHavingArgsDict']] havings: Zero or more filters used to restrict returned groups in the query result.
    :param int limit: The maximum number of query results, must be between 1 and 1000.
    :param Sequence[Union['GetQuerySpecificationOrderArgs', 'GetQuerySpecificationOrderArgsDict']] orders: Zero or more configuration blocks (described below) describing how to order the query results. Each term must appear in either `calculation` or `breakdowns`.
    :param int start_time: The absolute start time of the query in Unix Time (= seconds since epoch).
    :param int time_range: The time range of the query in seconds, defaults to `7200` (two hours).
    """
    __args__ = dict()
    __args__['breakdowns'] = breakdowns
    __args__['calculations'] = calculations
    __args__['endTime'] = end_time
    __args__['filterCombination'] = filter_combination
    __args__['filters'] = filters
    __args__['granularity'] = granularity
    __args__['havings'] = havings
    __args__['limit'] = limit
    __args__['orders'] = orders
    __args__['startTime'] = start_time
    __args__['timeRange'] = time_range
    opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
    __ret__ = pulumi.runtime.invoke('honeycomb:index/getQuerySpecification:GetQuerySpecification', __args__, opts=opts, typ=GetQuerySpecificationResult).value

    return AwaitableGetQuerySpecificationResult(
        breakdowns=pulumi.get(__ret__, 'breakdowns'),
        calculations=pulumi.get(__ret__, 'calculations'),
        end_time=pulumi.get(__ret__, 'end_time'),
        filter_combination=pulumi.get(__ret__, 'filter_combination'),
        filters=pulumi.get(__ret__, 'filters'),
        granularity=pulumi.get(__ret__, 'granularity'),
        havings=pulumi.get(__ret__, 'havings'),
        id=pulumi.get(__ret__, 'id'),
        json=pulumi.get(__ret__, 'json'),
        limit=pulumi.get(__ret__, 'limit'),
        orders=pulumi.get(__ret__, 'orders'),
        start_time=pulumi.get(__ret__, 'start_time'),
        time_range=pulumi.get(__ret__, 'time_range'))


@_utilities.lift_output_func(get_query_specification)
def get_query_specification_output(breakdowns: Optional[pulumi.Input[Optional[Sequence[str]]]] = None,
                                   calculations: Optional[pulumi.Input[Optional[Sequence[Union['GetQuerySpecificationCalculationArgs', 'GetQuerySpecificationCalculationArgsDict']]]]] = None,
                                   end_time: Optional[pulumi.Input[Optional[int]]] = None,
                                   filter_combination: Optional[pulumi.Input[Optional[str]]] = None,
                                   filters: Optional[pulumi.Input[Optional[Sequence[Union['GetQuerySpecificationFilterArgs', 'GetQuerySpecificationFilterArgsDict']]]]] = None,
                                   granularity: Optional[pulumi.Input[Optional[int]]] = None,
                                   havings: Optional[pulumi.Input[Optional[Sequence[Union['GetQuerySpecificationHavingArgs', 'GetQuerySpecificationHavingArgsDict']]]]] = None,
                                   limit: Optional[pulumi.Input[Optional[int]]] = None,
                                   orders: Optional[pulumi.Input[Optional[Sequence[Union['GetQuerySpecificationOrderArgs', 'GetQuerySpecificationOrderArgsDict']]]]] = None,
                                   start_time: Optional[pulumi.Input[Optional[int]]] = None,
                                   time_range: Optional[pulumi.Input[Optional[int]]] = None,
                                   opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetQuerySpecificationResult]:
    """
    ## # Data Source: get_query_specification

    Generates a [Query Specification](https://docs.honeycomb.io/api/query-specification/) in JSON format for use with resources that expect a JSON-formatted Query Specification like `Query`.

    Using this data source to generate query specifications is optional.
    It is also valid to use literal JSON strings in your configuration or to use the file interpolation function to read a raw JSON query specification from a file.

    ## Example Usage

    ```python
    import pulumi
    import pulumi_honeycomb as honeycomb

    example = honeycomb.get_query_specification(calculations=[{
            "op": "AVG",
            "column": "duration_ms",
        }],
        filters=[
            {
                "column": "trace.parent_id",
                "op": "does-not-exist",
            },
            {
                "column": "app.tenant",
                "op": "=",
                "value": "ThatSpecialTenant",
            },
        ],
        filter_combination="AND",
        breakdowns=["app.tenant"],
        time_range=28800)
    pulumi.export("jsonQuery", example.json)
    ```


    :param Sequence[str] breakdowns: A list of fields to group by.
    :param Sequence[Union['GetQuerySpecificationCalculationArgs', 'GetQuerySpecificationCalculationArgsDict']] calculations: Zero or more configuration blocks (described below) with the calculations that should be displayed. If no calculations are specified, `COUNT` will be used.
    :param int end_time: The absolute end time of the query in Unix Time (= seconds since epoch).
    :param str filter_combination: How to combine multiple filters, either `AND` (default) or `OR`.
    :param Sequence[Union['GetQuerySpecificationFilterArgs', 'GetQuerySpecificationFilterArgsDict']] filters: Zero or more configuration blocks (described below) with the filters that should be applied.
    :param int granularity: The time resolution of the query’s graph, in seconds. Valid values must be in between the query’s time range /10 at maximum, and /1000 at minimum.
           
           > **NOTE** It is not allowed to specify all three of `time_range`, `start_time` and `end_time`. For more details about specifying time windows, check [Query specification: A caveat on time](https://docs.honeycomb.io/api/query-specification/#a-caveat-on-time).
    :param Sequence[Union['GetQuerySpecificationHavingArgs', 'GetQuerySpecificationHavingArgsDict']] havings: Zero or more filters used to restrict returned groups in the query result.
    :param int limit: The maximum number of query results, must be between 1 and 1000.
    :param Sequence[Union['GetQuerySpecificationOrderArgs', 'GetQuerySpecificationOrderArgsDict']] orders: Zero or more configuration blocks (described below) describing how to order the query results. Each term must appear in either `calculation` or `breakdowns`.
    :param int start_time: The absolute start time of the query in Unix Time (= seconds since epoch).
    :param int time_range: The time range of the query in seconds, defaults to `7200` (two hours).
    """
    ...
