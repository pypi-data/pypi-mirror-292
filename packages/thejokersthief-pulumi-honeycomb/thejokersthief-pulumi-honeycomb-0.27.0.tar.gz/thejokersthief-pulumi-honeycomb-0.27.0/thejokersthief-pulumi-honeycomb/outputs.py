# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'ApiKeyPermissions',
    'BurnAlertRecipient',
    'BurnAlertRecipientNotificationDetails',
    'GetAuthMetadataApiKeyAccessResult',
    'GetAuthMetadataEnvironmentResult',
    'GetAuthMetadataTeamResult',
    'GetDatasetsDetailFilterResult',
    'GetEnvironmentsDetailFilterResult',
    'GetQuerySpecificationCalculationResult',
    'GetQuerySpecificationFilterResult',
    'GetQuerySpecificationHavingResult',
    'GetQuerySpecificationOrderResult',
    'GetSLOsDetailFilterResult',
    'TriggerEvaluationSchedule',
    'TriggerRecipient',
    'TriggerRecipientNotificationDetails',
    'TriggerThreshold',
]

@pulumi.output_type
class ApiKeyPermissions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createDatasets":
            suggest = "create_datasets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApiKeyPermissions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApiKeyPermissions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApiKeyPermissions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 create_datasets: Optional[bool] = None):
        """
        :param bool create_datasets: Allow this key to create missing datasets when sending telemetry. Defaults to `false`.
        """
        if create_datasets is not None:
            pulumi.set(__self__, "create_datasets", create_datasets)

    @property
    @pulumi.getter(name="createDatasets")
    def create_datasets(self) -> Optional[bool]:
        """
        Allow this key to create missing datasets when sending telemetry. Defaults to `false`.
        """
        return pulumi.get(self, "create_datasets")


@pulumi.output_type
class BurnAlertRecipient(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "notificationDetails":
            suggest = "notification_details"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BurnAlertRecipient. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BurnAlertRecipient.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BurnAlertRecipient.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: Optional[str] = None,
                 notification_details: Optional['outputs.BurnAlertRecipientNotificationDetails'] = None,
                 target: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str id: The ID of an already existing recipient. Should not be used in combination with `type` and `target`.
        :param 'BurnAlertRecipientNotificationDetailsArgs' notification_details: a block of additional details to send along with the notification. The only supported option currently is `pagerduty_severity` which has a default value of `critical` but can be set to one of `info`, `warning`, `error`, or `critical` and must be used in combination with a PagerDuty recipient.
               
               | Type      | Target              |
               |-----------|---------------------|
               | email     | an email address    |
               | pagerduty | _N/A_               |
               | slack     | name of the channel |
               | webhook   | name of the webhook |
        :param str target: Target of the recipient, this has another meaning depending on the type of recipient (see the table below). Should not be used in combination with `id`.
        :param str type: The type of the recipient, allowed types are `email`, `pagerduty`, `msteams`, `slack` and `webhook`. Should not be used in combination with `id`.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if notification_details is not None:
            pulumi.set(__self__, "notification_details", notification_details)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of an already existing recipient. Should not be used in combination with `type` and `target`.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="notificationDetails")
    def notification_details(self) -> Optional['outputs.BurnAlertRecipientNotificationDetails']:
        """
        a block of additional details to send along with the notification. The only supported option currently is `pagerduty_severity` which has a default value of `critical` but can be set to one of `info`, `warning`, `error`, or `critical` and must be used in combination with a PagerDuty recipient.

        | Type      | Target              |
        |-----------|---------------------|
        | email     | an email address    |
        | pagerduty | _N/A_               |
        | slack     | name of the channel |
        | webhook   | name of the webhook |
        """
        return pulumi.get(self, "notification_details")

    @property
    @pulumi.getter
    def target(self) -> Optional[str]:
        """
        Target of the recipient, this has another meaning depending on the type of recipient (see the table below). Should not be used in combination with `id`.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of the recipient, allowed types are `email`, `pagerduty`, `msteams`, `slack` and `webhook`. Should not be used in combination with `id`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class BurnAlertRecipientNotificationDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pagerdutySeverity":
            suggest = "pagerduty_severity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BurnAlertRecipientNotificationDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BurnAlertRecipientNotificationDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BurnAlertRecipientNotificationDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pagerduty_severity: Optional[str] = None):
        """
        :param str pagerduty_severity: The severity to set with the PagerDuty notification. If no severity is provided, 'critical' is assumed.
        """
        if pagerduty_severity is not None:
            pulumi.set(__self__, "pagerduty_severity", pagerduty_severity)

    @property
    @pulumi.getter(name="pagerdutySeverity")
    def pagerduty_severity(self) -> Optional[str]:
        """
        The severity to set with the PagerDuty notification. If no severity is provided, 'critical' is assumed.
        """
        return pulumi.get(self, "pagerduty_severity")


@pulumi.output_type
class GetAuthMetadataApiKeyAccessResult(dict):
    def __init__(__self__, *,
                 boards: bool,
                 columns: bool,
                 datasets: bool,
                 events: bool,
                 markers: bool,
                 queries: bool,
                 recipients: bool,
                 slos: bool,
                 triggers: bool):
        """
        :param bool boards: `true` if this API key can create and manage Boards.
        :param bool columns: `true` if this API key can create and manage can create and manage Queries, Columns, Derived Columns, and Query Annotations
        :param bool datasets: `true` if this API key can create and manage Datasets.
        :param bool events: `true` if this API key can key can send events to Honeycomb.
        :param bool markers: `true` if this API key can create and manage Markers.
        :param bool queries: `true` if this API key can execute existing Queries via the Query Data API.
        :param bool recipients: `true` if this API key can create and manage Recipients.
        :param bool slos: `true` if this API key can create and manage SLOs.
        :param bool triggers: `true` if this API key can create and manage Triggers.
        """
        pulumi.set(__self__, "boards", boards)
        pulumi.set(__self__, "columns", columns)
        pulumi.set(__self__, "datasets", datasets)
        pulumi.set(__self__, "events", events)
        pulumi.set(__self__, "markers", markers)
        pulumi.set(__self__, "queries", queries)
        pulumi.set(__self__, "recipients", recipients)
        pulumi.set(__self__, "slos", slos)
        pulumi.set(__self__, "triggers", triggers)

    @property
    @pulumi.getter
    def boards(self) -> bool:
        """
        `true` if this API key can create and manage Boards.
        """
        return pulumi.get(self, "boards")

    @property
    @pulumi.getter
    def columns(self) -> bool:
        """
        `true` if this API key can create and manage can create and manage Queries, Columns, Derived Columns, and Query Annotations
        """
        return pulumi.get(self, "columns")

    @property
    @pulumi.getter
    def datasets(self) -> bool:
        """
        `true` if this API key can create and manage Datasets.
        """
        return pulumi.get(self, "datasets")

    @property
    @pulumi.getter
    def events(self) -> bool:
        """
        `true` if this API key can key can send events to Honeycomb.
        """
        return pulumi.get(self, "events")

    @property
    @pulumi.getter
    def markers(self) -> bool:
        """
        `true` if this API key can create and manage Markers.
        """
        return pulumi.get(self, "markers")

    @property
    @pulumi.getter
    def queries(self) -> bool:
        """
        `true` if this API key can execute existing Queries via the Query Data API.
        """
        return pulumi.get(self, "queries")

    @property
    @pulumi.getter
    def recipients(self) -> bool:
        """
        `true` if this API key can create and manage Recipients.
        """
        return pulumi.get(self, "recipients")

    @property
    @pulumi.getter
    def slos(self) -> bool:
        """
        `true` if this API key can create and manage SLOs.
        """
        return pulumi.get(self, "slos")

    @property
    @pulumi.getter
    def triggers(self) -> bool:
        """
        `true` if this API key can create and manage Triggers.
        """
        return pulumi.get(self, "triggers")


@pulumi.output_type
class GetAuthMetadataEnvironmentResult(dict):
    def __init__(__self__, *,
                 classic: bool,
                 name: str,
                 slug: str):
        """
        :param bool classic: `true` if this API key belongs to a [Honeycomb Classic](https://docs.honeycomb.io/honeycomb-classic/) environment.
        :param str name: The name of the Team.
        :param str slug: The slug of the Team.
        """
        pulumi.set(__self__, "classic", classic)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "slug", slug)

    @property
    @pulumi.getter
    def classic(self) -> bool:
        """
        `true` if this API key belongs to a [Honeycomb Classic](https://docs.honeycomb.io/honeycomb-classic/) environment.
        """
        return pulumi.get(self, "classic")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Team.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def slug(self) -> str:
        """
        The slug of the Team.
        """
        return pulumi.get(self, "slug")


@pulumi.output_type
class GetAuthMetadataTeamResult(dict):
    def __init__(__self__, *,
                 name: str,
                 slug: str):
        """
        :param str name: The name of the Team.
        :param str slug: The slug of the Team.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "slug", slug)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Team.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def slug(self) -> str:
        """
        The slug of the Team.
        """
        return pulumi.get(self, "slug")


@pulumi.output_type
class GetDatasetsDetailFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 value: Optional[str] = None,
                 value_regex: Optional[str] = None):
        """
        :param str name: The name of the detail field to filter by. Currently only `name` is supported.
        :param str value: The value of the detail field to match on.
        :param str value_regex: A regular expression string to apply to the value of the detail field to match on.
               
               > **Note** one of `value` or `value_regex` is required.
        """
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_regex is not None:
            pulumi.set(__self__, "value_regex", value_regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the detail field to filter by. Currently only `name` is supported.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the detail field to match on.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueRegex")
    def value_regex(self) -> Optional[str]:
        """
        A regular expression string to apply to the value of the detail field to match on.

        > **Note** one of `value` or `value_regex` is required.
        """
        return pulumi.get(self, "value_regex")


@pulumi.output_type
class GetEnvironmentsDetailFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 value: Optional[str] = None,
                 value_regex: Optional[str] = None):
        """
        :param str name: The name of the detail field to filter by. Currently only `name` is supported.
        :param str value: The value of the detail field to match on.
        :param str value_regex: A regular expression string to apply to the value of the detail field to match on.
               
               > **Note** one of `value` or `value_regex` is required.
        """
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_regex is not None:
            pulumi.set(__self__, "value_regex", value_regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the detail field to filter by. Currently only `name` is supported.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the detail field to match on.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueRegex")
    def value_regex(self) -> Optional[str]:
        """
        A regular expression string to apply to the value of the detail field to match on.

        > **Note** one of `value` or `value_regex` is required.
        """
        return pulumi.get(self, "value_regex")


@pulumi.output_type
class GetQuerySpecificationCalculationResult(dict):
    def __init__(__self__, *,
                 op: str,
                 column: Optional[str] = None):
        """
        :param str op: The operator to apply, see the supported list of calculation operators at [Calculation Operators](https://docs.honeycomb.io/api/query-specification/#calculation-operators).
        :param str column: The column to apply the operator to, not needed with `COUNT` or `CONCURRENCY`.
        """
        pulumi.set(__self__, "op", op)
        if column is not None:
            pulumi.set(__self__, "column", column)

    @property
    @pulumi.getter
    def op(self) -> str:
        """
        The operator to apply, see the supported list of calculation operators at [Calculation Operators](https://docs.honeycomb.io/api/query-specification/#calculation-operators).
        """
        return pulumi.get(self, "op")

    @property
    @pulumi.getter
    def column(self) -> Optional[str]:
        """
        The column to apply the operator to, not needed with `COUNT` or `CONCURRENCY`.
        """
        return pulumi.get(self, "column")


@pulumi.output_type
class GetQuerySpecificationFilterResult(dict):
    def __init__(__self__, *,
                 column: str,
                 op: str,
                 value: Optional[str] = None):
        """
        :param str column: The column to apply the filter to.
        :param str op: The operator to apply, see the supported list of filter operators at [Filter Operators](https://docs.honeycomb.io/api/query-specification/#filter-operators). Not all operators require a value.
        :param str value: The value used for the filter. Not needed if op is `exists` or `not-exists`. Mutually exclusive with the other `value_*` options.
               
               * > **NOTE** Filter op `in` and `not-in` expect an array of strings as value. Use the `value` attribute and pass the values in single string separated by `,` without additional spaces (similar to the query builder in the UI). For example: the list `foo`, `bar` becomes `foo,bar`.
        """
        pulumi.set(__self__, "column", column)
        pulumi.set(__self__, "op", op)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def column(self) -> str:
        """
        The column to apply the filter to.
        """
        return pulumi.get(self, "column")

    @property
    @pulumi.getter
    def op(self) -> str:
        """
        The operator to apply, see the supported list of filter operators at [Filter Operators](https://docs.honeycomb.io/api/query-specification/#filter-operators). Not all operators require a value.
        """
        return pulumi.get(self, "op")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value used for the filter. Not needed if op is `exists` or `not-exists`. Mutually exclusive with the other `value_*` options.

        * > **NOTE** Filter op `in` and `not-in` expect an array of strings as value. Use the `value` attribute and pass the values in single string separated by `,` without additional spaces (similar to the query builder in the UI). For example: the list `foo`, `bar` becomes `foo,bar`.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetQuerySpecificationHavingResult(dict):
    def __init__(__self__, *,
                 calculate_op: str,
                 op: str,
                 value: float,
                 column: Optional[str] = None):
        """
        :param str calculate_op: The calculation operator to apply, supports all of the [Calculation Operators](https://docs.honeycomb.io/api/query-specification/#calculation-operators) with the exception of `HEATMAP`.
        :param str op: The operator to apply to filter the query results. One of `=`, `!=`, `>`, `>=`, `<`, or `<=`.
        :param float value: The value used with `op`. Currently assumed to be a number.
               
               > **NOTE** A having term's `column`/`calculate_op` pair must have a corresponding `calculation`. There can be multiple `having` blocks for the same `column`/`calculate_op` pair.
        :param str column: The column to apply the `calculate_op` to, not needed with `COUNT` or `CONCURRENCY`.
        """
        pulumi.set(__self__, "calculate_op", calculate_op)
        pulumi.set(__self__, "op", op)
        pulumi.set(__self__, "value", value)
        if column is not None:
            pulumi.set(__self__, "column", column)

    @property
    @pulumi.getter(name="calculateOp")
    def calculate_op(self) -> str:
        """
        The calculation operator to apply, supports all of the [Calculation Operators](https://docs.honeycomb.io/api/query-specification/#calculation-operators) with the exception of `HEATMAP`.
        """
        return pulumi.get(self, "calculate_op")

    @property
    @pulumi.getter
    def op(self) -> str:
        """
        The operator to apply to filter the query results. One of `=`, `!=`, `>`, `>=`, `<`, or `<=`.
        """
        return pulumi.get(self, "op")

    @property
    @pulumi.getter
    def value(self) -> float:
        """
        The value used with `op`. Currently assumed to be a number.

        > **NOTE** A having term's `column`/`calculate_op` pair must have a corresponding `calculation`. There can be multiple `having` blocks for the same `column`/`calculate_op` pair.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def column(self) -> Optional[str]:
        """
        The column to apply the `calculate_op` to, not needed with `COUNT` or `CONCURRENCY`.
        """
        return pulumi.get(self, "column")


@pulumi.output_type
class GetQuerySpecificationOrderResult(dict):
    def __init__(__self__, *,
                 column: Optional[str] = None,
                 op: Optional[str] = None,
                 order: Optional[str] = None):
        """
        :param str column: Either a column present in `breakdown` or a column that `op` applies to.
        :param str op: The calculation operator to apply, see the supported list of calculation operators at [Calculation Operators](https://docs.honeycomb.io/api/query-specification/#calculation-operators).
        :param str order: The sort direction, if set must be `ascending` or `descending`.
        """
        if column is not None:
            pulumi.set(__self__, "column", column)
        if op is not None:
            pulumi.set(__self__, "op", op)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def column(self) -> Optional[str]:
        """
        Either a column present in `breakdown` or a column that `op` applies to.
        """
        return pulumi.get(self, "column")

    @property
    @pulumi.getter
    def op(self) -> Optional[str]:
        """
        The calculation operator to apply, see the supported list of calculation operators at [Calculation Operators](https://docs.honeycomb.io/api/query-specification/#calculation-operators).
        """
        return pulumi.get(self, "op")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        The sort direction, if set must be `ascending` or `descending`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class GetSLOsDetailFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 value: Optional[str] = None,
                 value_regex: Optional[str] = None):
        """
        :param str name: The name of the detail field to filter by. Currently only `name` is supported.
        :param str value: The value of the detail field to match on.
        :param str value_regex: A regular expression string to apply to the value of the detail field to match on.
               
               > **Note** one of `value` or `value_regex` is required.
        """
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_regex is not None:
            pulumi.set(__self__, "value_regex", value_regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the detail field to filter by. Currently only `name` is supported.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the detail field to match on.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueRegex")
    def value_regex(self) -> Optional[str]:
        """
        A regular expression string to apply to the value of the detail field to match on.

        > **Note** one of `value` or `value_regex` is required.
        """
        return pulumi.get(self, "value_regex")


@pulumi.output_type
class TriggerEvaluationSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "daysOfWeeks":
            suggest = "days_of_weeks"
        elif key == "endTime":
            suggest = "end_time"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TriggerEvaluationSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TriggerEvaluationSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TriggerEvaluationSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 days_of_weeks: Sequence[str],
                 end_time: str,
                 start_time: str):
        """
        :param Sequence[str] days_of_weeks: A list of days of the week (in lowercase) to evaluate the trigger on
        :param str end_time: UTC time to stop evaluating the trigger in HH:mm format (e.g. `13:00`)
        :param str start_time: UTC time to start evaluating the trigger in HH:mm format (e.g. `13:00`)
        """
        pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Sequence[str]:
        """
        A list of days of the week (in lowercase) to evaluate the trigger on
        """
        return pulumi.get(self, "days_of_weeks")

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> str:
        """
        UTC time to stop evaluating the trigger in HH:mm format (e.g. `13:00`)
        """
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        """
        UTC time to start evaluating the trigger in HH:mm format (e.g. `13:00`)
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class TriggerRecipient(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "notificationDetails":
            suggest = "notification_details"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TriggerRecipient. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TriggerRecipient.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TriggerRecipient.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: Optional[str] = None,
                 notification_details: Optional['outputs.TriggerRecipientNotificationDetails'] = None,
                 target: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str id: The ID of an already existing recipient. Cannot not be used in combination with `type` and `target`.
        :param 'TriggerRecipientNotificationDetailsArgs' notification_details: a block of additional details to send along with the notification. The only supported option currently is `pagerduty_severity` which has a default value of `critical` but can be set to one of `info`, `warning`, `error`, or `critical` and must be used in combination with a PagerDuty recipient.
               
               Type      | Target
               ----------|-------------------------
               email     | an email address
               marker    | name of the marker
               pagerduty | _N/A_
               slack     | name of the channel
               webhook   | name of the webhook
        :param str target: Target of the trigger recipient, this has another meaning depending on the type of recipient (see the table below).
               Cannot not be used in combination with `id`.
        :param str type: The type of the trigger recipient, allowed types are `email`, `marker`, `msteams`, `pagerduty`, `slack` and `webhook`.
               Cannot not be used in combination with `id`.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if notification_details is not None:
            pulumi.set(__self__, "notification_details", notification_details)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of an already existing recipient. Cannot not be used in combination with `type` and `target`.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="notificationDetails")
    def notification_details(self) -> Optional['outputs.TriggerRecipientNotificationDetails']:
        """
        a block of additional details to send along with the notification. The only supported option currently is `pagerduty_severity` which has a default value of `critical` but can be set to one of `info`, `warning`, `error`, or `critical` and must be used in combination with a PagerDuty recipient.

        Type      | Target
        ----------|-------------------------
        email     | an email address
        marker    | name of the marker
        pagerduty | _N/A_
        slack     | name of the channel
        webhook   | name of the webhook
        """
        return pulumi.get(self, "notification_details")

    @property
    @pulumi.getter
    def target(self) -> Optional[str]:
        """
        Target of the trigger recipient, this has another meaning depending on the type of recipient (see the table below).
        Cannot not be used in combination with `id`.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of the trigger recipient, allowed types are `email`, `marker`, `msteams`, `pagerduty`, `slack` and `webhook`.
        Cannot not be used in combination with `id`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class TriggerRecipientNotificationDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pagerdutySeverity":
            suggest = "pagerduty_severity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TriggerRecipientNotificationDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TriggerRecipientNotificationDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TriggerRecipientNotificationDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pagerduty_severity: Optional[str] = None):
        """
        :param str pagerduty_severity: The severity to set with the PagerDuty notification. If no severity is provided, 'critical' is assumed.
        """
        if pagerduty_severity is not None:
            pulumi.set(__self__, "pagerduty_severity", pagerduty_severity)

    @property
    @pulumi.getter(name="pagerdutySeverity")
    def pagerduty_severity(self) -> Optional[str]:
        """
        The severity to set with the PagerDuty notification. If no severity is provided, 'critical' is assumed.
        """
        return pulumi.get(self, "pagerduty_severity")


@pulumi.output_type
class TriggerThreshold(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exceededLimit":
            suggest = "exceeded_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TriggerThreshold. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TriggerThreshold.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TriggerThreshold.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 op: str,
                 value: float,
                 exceeded_limit: Optional[int] = None):
        """
        :param str op: The operator to apply, allowed threshold operators are `>`, `>=`, `<`, and `<=`.
        :param float value: The value to be used with the operator.
        :param int exceeded_limit: The number of times the threshold is met before an alert is sent, must be between 1 and 5. Defaults to `1`.
        """
        pulumi.set(__self__, "op", op)
        pulumi.set(__self__, "value", value)
        if exceeded_limit is not None:
            pulumi.set(__self__, "exceeded_limit", exceeded_limit)

    @property
    @pulumi.getter
    def op(self) -> str:
        """
        The operator to apply, allowed threshold operators are `>`, `>=`, `<`, and `<=`.
        """
        return pulumi.get(self, "op")

    @property
    @pulumi.getter
    def value(self) -> float:
        """
        The value to be used with the operator.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="exceededLimit")
    def exceeded_limit(self) -> Optional[int]:
        """
        The number of times the threshold is met before an alert is sent, must be between 1 and 5. Defaults to `1`.
        """
        return pulumi.get(self, "exceeded_limit")


